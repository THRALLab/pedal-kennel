[global]
instructor = Instructor
tester = johna
gpt_model = gpt-4-0613
gpt_prompt = [
	  {
	    "feedback": [
	      [
	        {
	          "role": "system",
	          "content": "You are an intelligent tutor for a introductory computer science course in Python. You never give answers but do give helpful tips to guide students with their code."
	        },
	        {
	          "role": "assistant",
	          "content": "The student was given this programming problem:\nPrint an empty list literal value. That's it, just directly print the empty list literal value."
	        },
	        {
	          "role": "user",
	          "content": "{{STUDENT_CODE_HERE}}"
	        }
	      ],
	      {
	        "name": "add_code_feedback",
	        "description": "Adds feedback on the code for the student to view.",
	        "parameters": {
	          "type": "object",
	          "properties": {
	            "feedback": {
	              "type": "string",
	              "description": "Helpful tips to guide a student with their problematic code."
	            },
	            "is_error_present": {
	              "type": "boolean",
	              "description": "If there is a problem with the code, this parameter is true."
	            }
	          },
	          "required": [
	            "feedback",
	            "is_error_present"
	          ]
	        }
	      },
	      1.0,
	      1.0
	    ]
	  },
	  "<function get_prompts_getter.<locals>.get_default_prompts.<locals>.process_prompts at 0x00000225395FC7C0>"
	]
gpt_prompt_approximate_length = 468

[bakery_advanced_plotting_code_basic_scatter]
description = Let us return to the salary data we saw a few problems ago. Previously, we looked at the distribution of the `mean_salary` data. Now we will compare that data with the `median_salary` data and then the `members` data to see if there are any correlations. Create *two* visualizations:
	
	1. The first should show the relationship between `mean_salary` (x-axis) and `median_salary` (y-axis)
	2. The second should show the relationship between `mean_salary` (x-axis) and `members` (y-axis)
	
	Make sure you give meaningful labels to the axes and a title.
	
	You are provided the following code in the `bakery_salary.py` file. Assume `raw_salaries.csv` is a valid CSV file:
	
	```python
	from dataclasses import dataclass
	
	@dataclass
	class Industry:
	    """
	    Information about an individual industry.
	    
	    Attributes:
	        name: The name of the industry
	        members: The number of people employed in the industry.
	        mean_salary: The average salary of people in this industry.
	        median_salary: The median salary of people in this industry (more robust to outliers).
	    """
	    name: str
	    members: int
	    mean_salary: int
	    median_salary: int
	
	industries = []
	with open('raw_salaries.csv') as salary_file:
	    for line in salary_file:
	        name, members, mean, median = line.split("|")
	        industries.append(Industry(
	            name, int(members), int(mean), int(median)
	        ))
	```

[bakery_advanced_plotting_code_basic_scatter.Beedrill_37084628.py]
student_code = 
	from bakery_salary import industries
	import matplotlib.pyplot as plt
	
	mean_salaries = [industry.mean_salary for industry in industries]
	median_salaries = [industry.median_salary for industry in industries]
	members_list = [industry.members for industry in industries]
	
	plt.scatter(mean_salaries, median_salaries, label="Mean vs Median Salary")
	plt.scatter(mean_salaries, members, label="Mean Salaries vs Member Count")
	plt.xlabel("Mean Salary")
	plt.legend()
	plt.show()
gpt_feedback = You're on the right track collecting your data and setting up your scatter plots. However, you're trying to plot both relationships on the same graph which makes it potentially confusing to interpret. You should separate these into two separate graphs as the problem statement suggests.
	
	In addition, in the second scatter plot, you're trying to scatter `mean_salaries` and `members`, but there seems to be a mistake. You've collected the members data in `members_list`, but you're using `members` in your scatter plot. Try fixing this issue in your code.
gpt_feedback_length = 87
gpt_score = 0.0
pedal_feedback = The variable <code class='pedal-name'>members</code> was used on line 9, but it was not given a value on a previous line. You cannot use a variable until it has been given a value.
pedal_feedback_length = 32
pedal_score = 0
instructor_feedback_gpt_accurate = 5
instructor_feedback_gpt_concise = 2
instructor_feedback_gpt_clear = 5
instructor_feedback_gpt_jargon = 3
instructor_feedback_gpt_sentiment = 4
instructor_feedback_pedal_accurate = 3
instructor_feedback_pedal_concise = 4
instructor_feedback_pedal_clear = 2
instructor_feedback_pedal_jargon = 4
instructor_feedback_pedal_sentiment = 3

[bakery_advanced_plotting_code_basic_scatter.Buizel_37377473.py]
student_code = 
	from bakery_salary import industries
	
	import matplotlib.pyplot as plt
	
	
	mean_salary = [50, 90, 150, 200, 250]
	
	median_salary = [40, 80, 120, 180, 240]
	
	
	plt.scatter(mean_salary, median_salary)
	
	plt.xlabel('Mean Salary')
	
	plt.ylabel('Median Salary')
	
	plt.title('Relationship between Mean and Median Salary')
	
	plt.show()
gpt_feedback = There are several changes needed to completely solve this problem. First, your application does not load data from the `industries` list in `bakery_salary.py`. Second, you are only creating the first visualization, whereas the problem requires two. Try creating a list of `mean_salary` and `median_salary` from the `industries` list and use those in your scatter plot. Then do the same with `mean_salary` and `members` for the second plot.
gpt_feedback_length = 67
gpt_score = 0.0
pedal_feedback = The variable <code class='pedal-name'>industries</code> was given a value on line 1, but was never used after that.
pedal_feedback_length = 17
pedal_score = 0
instructor_feedback_gpt_accurate = 5
instructor_feedback_gpt_concise = 3
instructor_feedback_gpt_clear = 4
instructor_feedback_gpt_jargon = 3
instructor_feedback_gpt_sentiment = 4
instructor_feedback_pedal_accurate = 3
instructor_feedback_pedal_concise = 4
instructor_feedback_pedal_clear = 2
instructor_feedback_pedal_jargon = 4
instructor_feedback_pedal_sentiment = 3

[bakery_advanced_plotting_code_basic_scatter.Elgyem_36169335.py]
student_code = 
	from bakery_salary import industries
	import matplotlib.pyplot as plt
	
	mean=[]
	median=[]
	number=[]
	for industry in industries:
	    mean.append(industry.mean_salary)
	    median.append(industry.median_salary)
	    number.append(industry.members)
	        
	plt.scatter(mean,median)
	plt.xlablel(mean_salary)
	plt.ylablel(members)
	plt.show()
	
	plt.scatter(mean,number)
	plt.xlablel=(mean_salary)
	plt.ylablel=(median_salary)
	plt.show()
gpt_feedback = You've done a great job extracting the data and setting up the graphs. However, there are a couple of minor errors you need to fix:
	
	1. When you're adding labels to your graphs, you need to be careful about function names. You've written `xlablel` and `ylablel` instead of `xlabel` and `ylabel`.
	
	2. When calling the `xlabel` and `ylabel` functions, you need to pass a string argument to describe the label. 'mean_salary', 'median_salary' and 'members' should be enclosed in quotes to be recognized as strings. Moreover, make sure to use the correct labels for each plot.
	
	3. Unfortunately, `xlablel` and `ylablel` are not accepting their inputs correctly in the second plot. You've used `=` instead of parentheses. These should be function calls, similar to your earlier usage.
	
	Correct these issues and your visualizations should work properly.
gpt_feedback_length = 131
gpt_score = 0.0
pedal_feedback = The variable <code class='pedal-name'>mean_salary</code> was used on line 13, but it was not given a value on a previous line. You cannot use a variable until it has been given a value.
pedal_feedback_length = 32
pedal_score = 0
instructor_feedback_gpt_accurate = 5
instructor_feedback_gpt_concise = 1
instructor_feedback_gpt_clear = 5
instructor_feedback_gpt_jargon = 4
instructor_feedback_gpt_sentiment = 4
instructor_feedback_pedal_accurate = 3
instructor_feedback_pedal_concise = 4
instructor_feedback_pedal_clear = 2
instructor_feedback_pedal_jargon = 4
instructor_feedback_pedal_sentiment = 3

[bakery_advanced_plotting_code_basic_scatter.Girafarig_36476870.py]
student_code = 
	from bakery_salary import industries
	
	mean_salaries = []
	median_salaries = []
	for industry in industries:
	    mean_salaries.append(industry.mean_salary)
	    median_salaries.append(industry.median_salaries)
	
	plt.scatter(mean_salaries, median_salaries)
	plt.show()
	
	plt.scatter(median_salaries, mean_salaries)
	plt.show()
gpt_feedback = You seem to be almost there! Here are a few pointers though:
	
	1. You have a typo in the second loop when you append to `median_salaries`. You wrote `industry.median_salaries` but it should be `industry.median_salary`.
	
	2. You have swapped the x and y variables in your second scatter plot, be sure to get them the right way around.
	
	3. Remember to add axis labels and a title to each of your plots for clarity.
	
	4. You are missing the code to show the relationship between `mean_salary` and `members`.
	
	Fix these and you should be good to go!
gpt_feedback_length = 91
gpt_score = 0.0
pedal_feedback = You have imported the <code class='pedal-name'>plt</code> module, but you did not rename it to <code class='pedal-name'>matplotlib.pyplot</code> using <code>import matplotlib.pyplot as plt</code>.
pedal_feedback_length = 21
pedal_score = 0
instructor_feedback_gpt_accurate = 5
instructor_feedback_gpt_concise = 1
instructor_feedback_gpt_clear = 5
instructor_feedback_gpt_jargon = 4
instructor_feedback_gpt_sentiment = 4
instructor_feedback_pedal_accurate = 3
instructor_feedback_pedal_concise = 4
instructor_feedback_pedal_clear = 2
instructor_feedback_pedal_jargon = 4
instructor_feedback_pedal_sentiment = 3

[bakery_advanced_plotting_code_basic_scatter.Lapras_36250264.py]
student_code = 
	from bakery_salary import industries
	import matplotlib.pyplot as plt
	members = []
	mean = []
	median = []
	for industry in industries:
	    members.append(industry.members)
	    mean.append(industry.mean_salary)
	    median.append(industry.median_salary)
	plt.scatter(mean, median)
	plt.title('Mean vs Median')
	plt.ylabel('Median')
	plt.xlabel('Mean')
	plt.show()
	plt.scatter(mean, members)
	plt.title('Mean vs Members')
	plt.ylabel('Members')
	plt.xlabel('Mean')
	plt.show()
gpt_feedback = Your code is correct and it successfully plots two scatter plots comparing mean_salary with median_salary and mean_salary with members respectively. Good job using matplotlib's scatter function for this.
gpt_feedback_length = 28
gpt_score = 0.0
pedal_feedback = I ran your code.
	
	A ModuleNotFoundError occurred:
	
	<pre class='pedal-exception'>No module named 'bakery_salary'</pre>
	
	The traceback was:
	<div class='pedal-traceback'>Line 1 of file <code class='pedal-filename'>C:\Users\johna\Documents\pedal-kennel\examples\chosen_problems_st3-3_as3-3_at1_v1/bakery_advanced_plotting_code_basic_scatter/submissions/Lapras_36250264.py</code>
	<pre class='pedal-python-code python'><code>from bakery_salary import industries
	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</code></pre>
	</div>
pedal_feedback_length = 23
pedal_score = 0
instructor_feedback_gpt_accurate = 5
instructor_feedback_gpt_concise = 5
instructor_feedback_gpt_clear = 5
instructor_feedback_gpt_jargon = 1
instructor_feedback_gpt_sentiment = 5
instructor_feedback_pedal_accurate = 3
instructor_feedback_pedal_concise = 2
instructor_feedback_pedal_clear = 1
instructor_feedback_pedal_jargon = 5
instructor_feedback_pedal_sentiment = 3

[bakery_advanced_plotting_code_basic_scatter.Liepard_36306163.py]
student_code = 
	from bakery_salary import industries
	
	import matplotlib.pyplot as plt
	
	totalMS = []
	for industry in industries:
	    totalMS.append(industry.mean_salary / 1000)
	    
	plt.hist(totalMS)
	plt.xlabel("Mean Salary ($)")
	plt.ylabel("Industries")
	plt.title("Mean Salary of Industries")
	plt.show()
gpt_feedback = You are supposed to plot two scatter plots, one for comparing mean_salary with median_salary and the other for comparing mean_salary with members. You have instead plotted a histogram for just the mean_salaries. Use plt.scatter() for plotting scatter plots. Please revise your code to reflect these changes.
gpt_feedback_length = 46
gpt_score = 0.0
pedal_feedback = I ran your code.
	
	A ModuleNotFoundError occurred:
	
	<pre class='pedal-exception'>No module named 'bakery_salary'</pre>
	
	The traceback was:
	<div class='pedal-traceback'>Line 1 of file <code class='pedal-filename'>C:\Users\johna\Documents\pedal-kennel\examples\chosen_problems_st3-3_as3-3_at1_v1/bakery_advanced_plotting_code_basic_scatter/submissions/Liepard_36306163.py</code>
	<pre class='pedal-python-code python'><code>from bakery_salary import industries
	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</code></pre>
	</div>
pedal_feedback_length = 23
pedal_score = 0
instructor_feedback_gpt_accurate = 5
instructor_feedback_gpt_concise = 3
instructor_feedback_gpt_clear = 4
instructor_feedback_gpt_jargon = 1
instructor_feedback_gpt_sentiment = 3
instructor_feedback_pedal_accurate = 3
instructor_feedback_pedal_concise = 2
instructor_feedback_pedal_clear = 1
instructor_feedback_pedal_jargon = 5
instructor_feedback_pedal_sentiment = 3

[bakery_advanced_plotting_code_basic_scatter.Nosepass_36799328.py]
student_code = 
	from bakery_salary import industries
	import matplotlib.pyplot as plt
	
	mean_sal = []
	med_sal = []
	members = []
	for industry in industries:
	    mean_sal.append(industry.mean_salary)
	    med_sal.append(industry.med_sal)
	    members.append(industry.members)
	    
	plt.scatter(mean_sal, med_sal)
	plt.title('Mean and Median Salaries (U.S. DOL 2021)')
	plt.xlabel('Mean Salary')
	plt.ylabel('Median Salary')
	plt.show()
	
	plt.scatter(mean_sal, Members)
	plt.title('Mean and Memebers Salaries (U.S. DOL 2021)')
	plt.xlabel('Mean Salary')
	plt.ylabel('Number of Members')
	plt.show()
gpt_feedback = It seems like there is a minor error in your code. You're trying to use the attribute `med_sal` which does not exist in the `Industry` class. You should use `median_salary` instead. Moreover, in the second plot, you have used `Members` instead of `members` which will result in a `NameError`.
gpt_feedback_length = 49
gpt_score = 0.0
pedal_feedback = The variable <code class='pedal-name'>Members</code> was used on line 18, but it was not given a value on a previous line. You cannot use a variable until it has been given a value.
pedal_feedback_length = 32
pedal_score = 0
instructor_feedback_gpt_accurate = 5
instructor_feedback_gpt_concise = 4
instructor_feedback_gpt_clear = 4
instructor_feedback_gpt_jargon = 5
instructor_feedback_gpt_sentiment = 3
instructor_feedback_pedal_accurate = 3
instructor_feedback_pedal_concise = 4
instructor_feedback_pedal_clear = 2
instructor_feedback_pedal_jargon = 4
instructor_feedback_pedal_sentiment = 3

[bakery_advanced_plotting_code_basic_scatter.Nuzleaf_38568583.py]
student_code = 
	from bakery_salary import industries
	import matplotlib.pyplot as plt
	
	mean_salary_list=[]
	for industry in industries:
	    mean_salary_list.append(industry.mean_salary/1000)
	median_salary_list=[]
	for industry in industries:
	    median_salary_list.append(industry.median_salary)
	members_list=[]
	for industry in industries:
	    members_list.append(industry.members)
	plt.scatter(mean_salary_list, median_salary_list)
	plt.xlabel("Mean Salary")
	plt.ylabel("Median Salary")
	plt.title("Mean Salary Compared to Median Salary")
	plt.show
	plt.scatter(mean_salary_list, members)
	plt.xlabel("Mean Salary")
	plt.ylabel("Members")
	plt.title("Mean Salary Compared to Members")
	plt.show
gpt_feedback = Nice work, your code is almost correct. However, you forgot to divide median_salaries by 1000 to match with mean_salaries. Additionally, when you're plotting mean_salary_list against members, you've written 'members' instead of 'members_list'. Lastly, you forgot the '()' parentheses after plt.show, it should be plt.show().
gpt_feedback_length = 44
gpt_score = 0.0
pedal_feedback = You have not called the <code>plt.show</code> function, which actually creates the graph.
pedal_feedback_length = 12
pedal_score = 0
instructor_feedback_gpt_accurate = 5
instructor_feedback_gpt_concise = 4
instructor_feedback_gpt_clear = 5
instructor_feedback_gpt_jargon = 3
instructor_feedback_gpt_sentiment = 4
instructor_feedback_pedal_accurate = 5
instructor_feedback_pedal_concise = 5
instructor_feedback_pedal_clear = 5
instructor_feedback_pedal_jargon = 4
instructor_feedback_pedal_sentiment = 3

[bakery_for_composition_code_highest_filter]
description = Define the function `high_score` that consumes a list of integers (representing scores in a game) and produces an integer representing the highest score in the list. Ignore scores less than `100`, and stop processing values if you encounter `-999`. If the list is empty, return the value `None` instead. It is up to you to decompose this function (or not) however you want.

[bakery_for_composition_code_highest_filter.Beedrill_29030778.py]
student_code = 
	from bakery import assert_equal
	
	def high_score(scores: [int]) -> int:
	    if [i for i in scores if i >= 100] == []:
	        return None
	    to_return = 100
	    for score in scores:
	        if score == -999:
	            break
	        elif score >= to_return:
	            to_return = score
	    return to_return
	
	
	assert_equal(high_score([98, 100, 99, 101, -999, 102]), 101)
	assert_equal(high_score([]), None)
	assert_equal(high_score([70]), None)
gpt_feedback = Nice work! Your function seems to be correctly identifying the highest score, ignoring scores below 100, and stopping when it encounters -999. The only minor problem I see is the initialization of 'to_return'. It's starting at '100', which could potentially produce incorrect results if all the scores are less than 100 but none of them are below zero. I would suggest you initialize 'to_return' to 'None' instead, and handle the case where 'to_return' remains 'None'
gpt_feedback_length = 75
gpt_score = 0.0
pedal_feedback = Student code failed instructor tests.
	You passed 6/8 tests.
	
	I ran your function <code class='pedal-name'>high_score</code> on some new arguments.
	<table class='pedal-table'>   <tr class='pedal-header'>
	    <th class='pedal-cell'></th>
	    <th class='pedal-cell'>Arguments</th>
	    <th class='pedal-cell'>Returned</th>
	    <th class='pedal-cell'>Expected</th>
	  </tr>     <tr class='pedal-row'>
	    <td class='pedal-cell'><span class='pedal-positive-mark'>&#10004;</span></td>
	    <td class='pedal-cell'><pre class='pedal-python-code python'><code>[100, 200, 300, -999]</code></pre></td>
	    <td class='pedal-cell'>300</td>
	    <td class='pedal-cell'>300</td>
	  </tr>
	  <tr class='pedal-row'>
	    <td class='pedal-cell'><span class='pedal-positive-mark'>&#10004;</span></td>
	    <td class='pedal-cell'><pre class='pedal-python-code python'><code>[300, 200, 100, -999]</code></pre></td>
	    <td class='pedal-cell'>300</td>
	    <td class='pedal-cell'>300</td>
	  </tr>
	  <tr class='pedal-row'>
	    <td class='pedal-cell'><span class='pedal-positive-mark'>&#10004;</span></td>
	    <td class='pedal-cell'><pre class='pedal-python-code python'><code>[300, 200, -999, 500, 400]</code></pre></td>
	    <td class='pedal-cell'>300</td>
	    <td class='pedal-cell'>300</td>
	  </tr>
	  <tr class='pedal-row'>
	    <td class='pedal-cell'><span class='pedal-positive-mark'>&#10004;</span></td>
	    <td class='pedal-cell'><pre class='pedal-python-code python'><code>[400, 200, -999, 100, 200]</code></pre></td>
	    <td class='pedal-cell'>400</td>
	    <td class='pedal-cell'>400</td>
	  </tr>
	  <tr class='pedal-row'>
	    <td class='pedal-cell'><span class='pedal-negative-mark'>&#10060;</span></td>
	    <td class='pedal-cell'><pre class='pedal-python-code python'><code>[-999, 400, 300, 50]</code></pre></td>
	    <td class='pedal-cell'>100</td>
	    <td class='pedal-cell'>None</td>
	  </tr>
	  <tr class='pedal-row'>
	    <td class='pedal-cell'><span class='pedal-positive-mark'>&#10004;</span></td>
	    <td class='pedal-cell'><pre class='pedal-python-code python'><code>[-999]</code></pre></td>
	    <td class='pedal-cell'>None</td>
	    <td class='pedal-cell'>None</td>
	  </tr>
	  <tr class='pedal-row'>
	    <td class='pedal-cell'><span class='pedal-negative-mark'>&#10060;</span></td>
	    <td class='pedal-cell'><pre class='pedal-python-code python'><code>[20, 40, 30, -999, 100]</code></pre></td>
	    <td class='pedal-cell'>100</td>
	    <td class='pedal-cell'>None</td>
	  </tr>
	  <tr class='pedal-row'>
	    <td class='pedal-cell'><span class='pedal-positive-mark'>&#10004;</span></td>
	    <td class='pedal-cell'><pre class='pedal-python-code python'><code>[50, 200, -999, 50]</code></pre></td>
	    <td class='pedal-cell'>200</td>
	    <td class='pedal-cell'>200</td>
	  </tr></table>
pedal_feedback_length = 295
pedal_score = 0
instructor_feedback_gpt_accurate = 5
instructor_feedback_gpt_concise = 3
instructor_feedback_gpt_clear = 4
instructor_feedback_gpt_jargon = 3
instructor_feedback_gpt_sentiment = 4
instructor_feedback_pedal_accurate = 3
instructor_feedback_pedal_concise = 1
instructor_feedback_pedal_clear = 1
instructor_feedback_pedal_jargon = 5
instructor_feedback_pedal_sentiment = 3

[bakery_for_composition_code_highest_filter.Buizel_29317817.py]
student_code = 
	from bakery import assert_equal
	
	def high_score(scores: list[int]) -> int:
	    high = scores[0]
	    for score in scores:
	        if score > high:
	            high = score
	    return high
gpt_feedback = Good start, but there are some missing elements in your function. Remember, you need to ignore scores less than 100 and stop processing values if you encounter -999. Also, your current function doesn't handle the case where the input list is empty. Take into account these special cases in your code.
gpt_feedback_length = 51
gpt_score = 0.0
pedal_feedback = The function <code class='pedal-name'>assert_equal</code> was given a definition on line 1, but was never used after that.
pedal_feedback_length = 17
pedal_score = 0
instructor_feedback_gpt_accurate = 5
instructor_feedback_gpt_concise = 4
instructor_feedback_gpt_clear = 4
instructor_feedback_gpt_jargon = 3
instructor_feedback_gpt_sentiment = 2
instructor_feedback_pedal_accurate = 3
instructor_feedback_pedal_concise = 4
instructor_feedback_pedal_clear = 2
instructor_feedback_pedal_jargon = 4
instructor_feedback_pedal_sentiment = 3

[bakery_for_composition_code_highest_filter.Darumaka_29509864.py]
student_code = 
	from bakery import assert_equal
	
	
	def high_score (scores:list[int])->int:
	    maximum=score[0]
	    for score in scores:
	        if score > maximum:
	            if score < 100:
	                return None 
	            maximum=score
	    return maximum
	
	assert_equal(high_score([500,50]), 500)
gpt_feedback = You are on the right track! However, there are a few things you missed:
	
	1. There's a typo in your function: `maximum=score[0]` is incorrect because `score` is not defined yet. It should be `scores[0]`.
	
	2. You are supposed to ignore scores less than `100`, but in your code, you are returning None if the score is less than `100`. You should continue with the loop instead.
	
	3. You need to account for the `-999` condition. This means whenever you encounter `-999`, you should stop processing values.
	
	4. You also need to handle the case when the list is empty. In the current code, if an empty list is passed, it will throw an error because you are trying to access the first element of the list that doesn't exist.
	
	Please adjust your function according to these pointers and try again.
gpt_feedback_length = 135
gpt_score = 0.0
pedal_feedback = The variable <code class='pedal-name'>score</code> was used on line 5, but it was not given a value on a previous line. You cannot use a variable until it has been given a value.
pedal_feedback_length = 32
pedal_score = 0
instructor_feedback_gpt_accurate = 5
instructor_feedback_gpt_concise = 1
instructor_feedback_gpt_clear = 5
instructor_feedback_gpt_jargon = 4
instructor_feedback_gpt_sentiment = 4
instructor_feedback_pedal_accurate = 3
instructor_feedback_pedal_concise = 3
instructor_feedback_pedal_clear = 3
instructor_feedback_pedal_jargon = 4
instructor_feedback_pedal_sentiment = 3

[bakery_for_composition_code_highest_filter.Elgyem_27313994.py]
student_code = 
	from bakery import assert_equal
	def high_score(scores: [int])->int:
	
	max_num = scores[0]
	
	mini = 100
	
	empty_list = []
	
	if scores == empty_list:
	    return None
	for score in scores:
	    if score==-999:
	        return max_num
	    if score < mini:
	        continue
	    if score == -999:
	        break
	    if score > max_num:
	        max_num = score
	        return max_num
	
	assert_equal(high_score([300, 40, 200, 150]), 300)
	
	assert_equal(high_score([50, 100, 400, -999]), 400)
	
	assert_equal(high_score([600, 800,]), 800)
	
	assert_equal(high_score([300, 200, -999, 400]), 300)
gpt_feedback = Your code seems to have a few issues. First, `return max_num` should not be inside the for loop. It should be outside and at the end of the function because you want to go through the entire list before you return the maximum number. Remember, the return statement stops the execution of a function and sends the result back to the caller. When you put it in the loop, it exits the function on the first iteration where score is greater than `max_num`.
	
	Second, the `score==-999` and `score == '-999'` are redundant. It's enough to have the first `score==-999` You also have to return `max_num` after `score==-999` instead of `'break'` because you don't want your function to continue when it encounters '-999'.
	
	Additionally, I see you're checking whether the provided list is equal to `empty_list`. There's a simpler way to do this. You can just check if `not scores` instead of `scores == empty_list`.
	
	Lastly, you need to initialize `max_num` to `-float('inf')` or `None`, not `scores[0]`, because you are supposed to ignore scores less than 100, and if `scores[0]` is less than 100, then `max_num` starts out being less than 100.
gpt_feedback_length = 188
gpt_score = 0.0
pedal_feedback = Bad indentation on line 4 or adjacent line.
	
	The traceback was:
	<div class='pedal-traceback'>Line 4 of file <code class='pedal-filename'>C:\Users\johna\Documents\pedal-kennel\examples\chosen_problems_st3-3_as3-3_at1_v1/bakery_for_composition_code_highest_filter/submissions/Elgyem_27313994.py</code>
	<pre class='pedal-python-code python'><code>max_num = scores[0]
	^</code></pre>
	</div>
	Expected an indented block after function definition on line 2.
	Suggestion: Check line 4, the line before it, and the line after it. Ignore blank lines.
pedal_feedback_length = 44
pedal_score = 0
instructor_feedback_gpt_accurate = 5
instructor_feedback_gpt_concise = 1
instructor_feedback_gpt_clear = 4
instructor_feedback_gpt_jargon = 4
instructor_feedback_gpt_sentiment = 4
instructor_feedback_pedal_accurate = 4
instructor_feedback_pedal_concise = 2
instructor_feedback_pedal_clear = 1
instructor_feedback_pedal_jargon = 5
instructor_feedback_pedal_sentiment = 3

[bakery_for_composition_code_highest_filter.Girafarig_28396215.py]
student_code = 
	from bakery import assert_equal
	
	def high_score(scores: list[int]) -> int:
	    if not scores:
	        return None
	    highest_score = scores[0]
	    taking = True
	    for score in scores:
	        if -999 == score:
	            taking = False
	        elif taking and score >= 100 and score > highest_score:
	            highest_score = score
	    if highest_score < 100:
	        return None
	    return highest_score
	
	assert_equal(high_score([101, 150, 175, -10, 53]), 175)
	assert_equal(high_score([52, 63]), None)
	assert_equal(high_score([105, -999, 175, -10, 53]), 105)
	assert_equal(high_score([]), None)
gpt_feedback = Your code looks good! It correctly checks for each condition given in the problem statement. It handles the empty list, ignores scores under 100, and stops processing the scores when it encounters -999. And it returns the highest score successfully. Keep up the good work.
gpt_feedback_length = 45
gpt_score = 0.0
pedal_feedback = Great work!
pedal_feedback_length = 2
pedal_score = 1
instructor_feedback_gpt_accurate = 5
instructor_feedback_gpt_concise = 3
instructor_feedback_gpt_clear = 5
instructor_feedback_gpt_jargon = 4
instructor_feedback_gpt_sentiment = 5
instructor_feedback_pedal_accurate = 5
instructor_feedback_pedal_concise = 5
instructor_feedback_pedal_clear = 5
instructor_feedback_pedal_jargon = 1
instructor_feedback_pedal_sentiment = 5

[bakery_for_composition_code_highest_filter.Lapras_28139989.py]
student_code = 
	from bakery import assert_equal
	def high_score(List:list[int])-> int:
	    max = List[0]
	    cont_count = True
	    for nums in List:
	        if nums == -999:
	            cont_count = False
	            if nums >=100:
	                max = nums
	    return max
	
	assert_equal(high_score([150, -999, 200]), 150)
gpt_feedback = This is a good start, however, there seems to be an issue. Your code is only checking if a number is greater or equal to 100 after it encounters -999 in the list, having already set the continue flag as False. As a result, it will not check for numbers greater or equal to 100 after the -999. Also, there is no handling for empty lists.  Lastly, you should only update your max value if the current element is greater than the current max, which is not the case in your implementation.
gpt_feedback_length = 93
gpt_score = 0.0
pedal_feedback = The variable <code class='pedal-name'>cont_count</code> was given a value on line 6, but was never used after that.
pedal_feedback_length = 17
pedal_score = 0
instructor_feedback_gpt_accurate = 5
instructor_feedback_gpt_concise = 2
instructor_feedback_gpt_clear = 5
instructor_feedback_gpt_jargon = 3
instructor_feedback_gpt_sentiment = 4
instructor_feedback_pedal_accurate = 3
instructor_feedback_pedal_concise = 4
instructor_feedback_pedal_clear = 2
instructor_feedback_pedal_jargon = 4
instructor_feedback_pedal_sentiment = 3

[bakery_for_composition_code_highest_filter.Liepard_28823730.py]
student_code = 
	from bakery import assert_equal
	
	def high_score(integers: list[int]) -> int:
	    highest = integers[0]
	    if len(integers) > 0:
	        for integer in integers:
	            if integer == -999:
	                return None
	            if integer >= 100:
	                if highest < integer:
	                    highest = integer
	        return highest
gpt_feedback = Your code has a logical error. You need to return None only when the list is empty. But in your code, in the case where you encounter -999, you should immediately stop processing the list and return the highest score so far (if any). Currently, you're returning None instead, which is incorrect. You also mistakenly set the highest score to the first element of the list before checking if it meets the given conditions (it should be over 100 and not -999). Try initializing 'highest' as None and then update it only when you find a value over 100.
gpt_feedback_length = 99
gpt_score = 0.0
pedal_feedback = The function <code class='pedal-name'>assert_equal</code> was given a definition on line 1, but was never used after that.
pedal_feedback_length = 17
pedal_score = 0
instructor_feedback_gpt_accurate = 5
instructor_feedback_gpt_concise = 3
instructor_feedback_gpt_clear = 4
instructor_feedback_gpt_jargon = 3
instructor_feedback_gpt_sentiment = 4
instructor_feedback_pedal_accurate = 3
instructor_feedback_pedal_concise = 4
instructor_feedback_pedal_clear = 2
instructor_feedback_pedal_jargon = 4
instructor_feedback_pedal_sentiment = 3

[bakery_for_composition_code_highest_filter.Nosepass_28623443.py]
student_code = 
	from bakery import assert_equal
	
	def filter_scores(scores: list[int])->list[int]:
	    #filter the scores
	    New_Scores = []
	    for score in scores:
	        if score == -999:
	            return New_Scores
	        if score > 100:
	            New_Scores.append(score)
	    return New_Scores
	
	def high_score(raw_scores: list[int])->int:
	    scores = filter_scores(raw_scores)
	    if not scores:
	        return None
	    max_s = scores[0]
	    for score in score:
	        if score > max_s:
	    return max_s
	
	assert_equal(filter_scores([1,-999,300]),[])
	assert_equal(filter_scores([1,300,500]),[300,500])
	assert_equal(filter_scores([1000,300,101]),[1000,300,101])
	
	assert_equal(high_score([1,-999,300]),None)
	assert_equal(high_score([300,200,3000]),3000)
	assert_equal(high_score([101,3,54]),101)
gpt_feedback = You're on the right track. I see you created two functions, one to filter the scores and the other to find the highest score. However, I observed a few issues that need to be fixed. In the `filter_scores` function, your condition checks if the score is greater than 100 but the problem statement asks to ignore scores less than 100. In the `high_scores` function, you missed an indent under the `if` statement where you are finding the maximum score. Additionally, in the loop where you are iterating over the scores, you are using the variable `score` but in the for loop condition you wrote `for score in score:` which would cause a NameError since you are using the same name for the list and its elements. It would be better to use a different name such as `scores` for the list and `score` for the elements.
gpt_feedback_length = 146
gpt_score = 0.0
pedal_feedback = Bad indentation on line 20 or adjacent line.
	
	The traceback was:
	<div class='pedal-traceback'>Line 20 of file <code class='pedal-filename'>C:\Users\johna\Documents\pedal-kennel\examples\chosen_problems_st3-3_as3-3_at1_v1/bakery_for_composition_code_highest_filter/submissions/Nosepass_28623443.py</code>
	<pre class='pedal-python-code python'><code>    return max_s
	   ^</code></pre>
	</div>
	Expected an indented block after 'if' statement on line 19.
	Suggestion: Check line 20, the line before it, and the line after it. Ignore blank lines.
pedal_feedback_length = 50
pedal_score = 0
instructor_feedback_gpt_accurate = 5
instructor_feedback_gpt_concise = 3
instructor_feedback_gpt_clear = 5
instructor_feedback_gpt_jargon = 3
instructor_feedback_gpt_sentiment = 4
instructor_feedback_pedal_accurate = 3
instructor_feedback_pedal_concise = 2
instructor_feedback_pedal_clear = 1
instructor_feedback_pedal_jargon = 5
instructor_feedback_pedal_sentiment = 3

[bakery_for_composition_code_highest_filter.Nuzleaf_32379968.py]
student_code = 
	from bakery import assert_equal
	
	def no_less_than_100(numbers:list[int])->list[int]:
	    stitch=[]
	    for number in numbers:
	        if number>=100:
	            stitch.append(number)
	    return stitch
	
	def maximum(numbers:list[int])->int:
	    purple=numbers[0]
	    for number in numbers:
	        if purple<number:
	            purple=number
	    return purple
	
	def
	        
	def high_score(numbers:list[int])->int:
	    x=no_less_than_100(numbers)
	    if not numbers:
	        return None   
	    taking=True
	    lilo=[]
	    for number in x:
	    if number==-999:
	        taking=False
	    elif taking:   
	        lilo.append(number)
	    return maximum(lilo)
	    
	assert_equal(high_score([]), None)
	assert_equal(high_score([99,2,101,100]), 101)
	assert_equal(high_score([5,-999]), 0)
gpt_feedback = It seems like there are some issues in your code. Firstly, you appear to have accidentally declared an incomplete `def` statement in your script. You should remove this if it's not needed. Secondly, the assert test for `high_score([5,-999])` expects `0` as a return value. However, according to the problem description, you should ignore numbers less than 100 and if you encounter `-999`, you should stop processing values. So, in this case should actually return `None` as you haven't encountered any valid score and upon reaching `-999`, you've stopped. Also, there's an indentation error with line `if number==-999:`. It should be indented properly under the 'for' loop.
gpt_feedback_length = 106
gpt_score = 0.0
pedal_feedback = Bad syntax on line 17.
	
	The traceback was:
	<div class='pedal-traceback'>Line 17 of file <code class='pedal-filename'>C:\Users\johna\Documents\pedal-kennel\examples\chosen_problems_st3-3_as3-3_at1_v1/bakery_for_composition_code_highest_filter/submissions/Nuzleaf_32379968.py</code>
	<pre class='pedal-python-code python'><code>def
	   ^</code></pre>
	</div>
	Invalid syntax.
	Suggestion: Check line 17, the line before it, and the line after it. Ignore blank lines.
pedal_feedback_length = 34
pedal_score = 0
instructor_feedback_gpt_accurate = 5
instructor_feedback_gpt_concise = 3
instructor_feedback_gpt_clear = 5
instructor_feedback_gpt_jargon = 2
instructor_feedback_gpt_sentiment = 2
instructor_feedback_pedal_accurate = 5
instructor_feedback_pedal_concise = 4
instructor_feedback_pedal_clear = 1
instructor_feedback_pedal_jargon = 5
instructor_feedback_pedal_sentiment = 3

[bakery_functions_flow_code_timely_extraction]
description = <p>The functions below calculate whether a given hour is in the morning (between 5am <em>and</em> 12pm). The first function <code>is_morning</code> (incomplete) has two helper functions (<code>is_past_dawn</code> and <code>is_before_noon</code>, both complete). Finish the <code>is_morning</code> function to call the other two.</p>

[bakery_functions_flow_code_timely_extraction.Beedrill_18988758.py]
student_code = 
	from cisc108 import assert_equal
	
	def is_before_noon(hour: int) -> bool:
	    return hour <= 12
	
	def is_past_dawn(hour: int) -> bool:
	    return hour >= 5
	
	def is_morning(hour: int) -> bool:
	    return is_past_dawn(hour) and is_before_noon(hour)
	
	assert_equal(is_morning(1), False)
	assert_equal(is_morning(6), True)
	assert_equal(is_morning(11), True)
	assert_equal(is_morning(14), False)
gpt_feedback = Congratulations, your code is working as expected. You've correctly utilized helper functions in your main function to determine if a certain hour is in the morning. Also, your tests check various cases which ensure the validity of your function. Well done!
gpt_feedback_length = 41
gpt_score = 0.0
pedal_feedback = I ran your code.
	
	A ModuleNotFoundError occurred:
	
	<pre class='pedal-exception'>No module named 'cisc108'</pre>
	
	The traceback was:
	<div class='pedal-traceback'>Line 1 of file <code class='pedal-filename'>C:\Users\johna\Documents\pedal-kennel\examples\chosen_problems_st3-3_as3-3_at1_v1/bakery_functions_flow_code_timely_extraction/submissions/Beedrill_18988758.py</code>
	<pre class='pedal-python-code python'><code>from cisc108 import assert_equal
	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</code></pre>
	</div>
pedal_feedback_length = 23
pedal_score = 0
instructor_feedback_gpt_accurate = 5
instructor_feedback_gpt_concise = 5
instructor_feedback_gpt_clear = 5
instructor_feedback_gpt_jargon = 2
instructor_feedback_gpt_sentiment = 5
instructor_feedback_pedal_accurate = 3
instructor_feedback_pedal_concise = 4
instructor_feedback_pedal_clear = 1
instructor_feedback_pedal_jargon = 5
instructor_feedback_pedal_sentiment = 3

[bakery_functions_flow_code_timely_extraction.Buizel_20306146.py]
student_code = 
	from bakery import assert_equal
	
	def is_before_noon(hour: int) -> bool:
	    return hour <= 12
	
	def is_past_dawn(hour: int) -> bool:
	    return hour >= 5
	
	def is_morning(hour: int) -> bool:
	    return ___
	
	assert_equal(is_morning(1), False)
	assert_equal(is_morning(6), True)
	assert_equal(is_morning(11), True)
	assert_equal(is_morning(14), False)
gpt_feedback = It seems you've left the is_morning function incomplete. Here's a hint: If the hour is in the morning, it's both after dawn and before noon. Can you use the helper functions to check both conditions are met?
gpt_feedback_length = 37
gpt_score = 0.0
pedal_feedback = It looks like you have unconnected blocks on line 10. Before you run your program, you must make sure that all of your blocks are connected that there are no unfilled holes.
pedal_feedback_length = 32
pedal_score = 0
instructor_feedback_gpt_accurate = 5
instructor_feedback_gpt_concise = 5
instructor_feedback_gpt_clear = 5
instructor_feedback_gpt_jargon = 2
instructor_feedback_gpt_sentiment = 5
instructor_feedback_pedal_accurate = 5
instructor_feedback_pedal_concise = 4
instructor_feedback_pedal_clear = 3
instructor_feedback_pedal_jargon = 4
instructor_feedback_pedal_sentiment = 3

[bakery_functions_flow_code_timely_extraction.Darumaka_20596757.py]
student_code = 
	from cisc108 import assert_equal
	
	def is_before_noon(hour: int) -> bool:
	    return hour <= 12
	
	def is_past_dawn(hour: int) -> bool:
	    return hour >= 5
	
	def is_morning(hour: int) -> bool:
	    return hour 
	
	assert_equal(is_morning(1), False)
	assert_equal(is_morning(6), True)
	assert_equal(is_morning(11), True)
	assert_equal(is_morning(14), False)
gpt_feedback = The `is_morning` function is currently incorrectly returning the hour, which is an integer, instead of a boolean. To solve this problem, you need to use both helper functions inside your `is_morning` function. You will want to return true if the hour is past dawn and before noon.
gpt_feedback_length = 47
gpt_score = 0.0
pedal_feedback = Your function returned an integer on line 12, even though you defined it to return a boolean. Your function should return values consistently.
pedal_feedback_length = 23
pedal_score = 0
instructor_feedback_gpt_accurate = 5
instructor_feedback_gpt_concise = 4
instructor_feedback_gpt_clear = 4
instructor_feedback_gpt_jargon = 3
instructor_feedback_gpt_sentiment = 3
instructor_feedback_pedal_accurate = 4
instructor_feedback_pedal_concise = 4
instructor_feedback_pedal_clear = 3
instructor_feedback_pedal_jargon = 3
instructor_feedback_pedal_sentiment = 3

[bakery_functions_flow_code_timely_extraction.Elgyem_18650843.py]
student_code = 
	from cisc108 import assert_equal
	
	def is_before_noon(hour: int) -> bool:
	    return hour <= 12
	
	def is_past_dawn(hour: int) -> bool:
	    return hour >= 5
	
	def is_morning(hour: int) -> bool:
	    return ___
	
	assert_equal(is_morning(1), False)
	assert_equal(is_morning(6), True)
	assert_equal(is_morning(11), True)
	assert_equal(is_morning(14), False)
gpt_feedback = The is_morning function needs to make use of both helper functions to determine if a given hour falls within the morning time. You will have to call is_before_noon and is_past_dawn within is_morning and return their outputs in a way that checks if the hour is both past dawn (>=5) and before noon (<=12). Note that logical operators can be very helpful in this task.
gpt_feedback_length = 64
gpt_score = 0.0
pedal_feedback = It looks like you have unconnected blocks on line 10. Before you run your program, you must make sure that all of your blocks are connected that there are no unfilled holes.
pedal_feedback_length = 32
pedal_score = 0
instructor_feedback_gpt_accurate = 5
instructor_feedback_gpt_concise = 4
instructor_feedback_gpt_clear = 5
instructor_feedback_gpt_jargon = 3
instructor_feedback_gpt_sentiment = 3
instructor_feedback_pedal_accurate = 5
instructor_feedback_pedal_concise = 4
instructor_feedback_pedal_clear = 3
instructor_feedback_pedal_jargon = 4
instructor_feedback_pedal_sentiment = 3

[bakery_functions_flow_code_timely_extraction.Girafarig_19721299.py]
student_code = 
	from cisc108 import assert_equal
	
	def is_before_noon(hour: int) -> bool:
	    return hour <= 12
	
	def is_past_dawn(hour: int) -> bool:
	    return hour >= 5
	
	def is_morning(hour: int) -> bool:
	    return is_past_dawn(hour) and is_before_noon(hour)
	
	assert_equal(is_morning(1), False)
	assert_equal(is_morning(6), True)
	assert_equal(is_morning(11), True)
	assert_equal(is_morning(14), False)
gpt_feedback = Great job! Your `is_morning` function correctly uses the `is_past_dawn` and `is_before_noon` functions. Your test cases are also comprehensive, testing times before, during, and after the morning hours.
gpt_feedback_length = 27
gpt_score = 0.0
pedal_feedback = I ran your code.
	
	A ModuleNotFoundError occurred:
	
	<pre class='pedal-exception'>No module named 'cisc108'</pre>
	
	The traceback was:
	<div class='pedal-traceback'>Line 1 of file <code class='pedal-filename'>C:\Users\johna\Documents\pedal-kennel\examples\chosen_problems_st3-3_as3-3_at1_v1/bakery_functions_flow_code_timely_extraction/submissions/Girafarig_19721299.py</code>
	<pre class='pedal-python-code python'><code>from cisc108 import assert_equal
	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</code></pre>
	</div>
pedal_feedback_length = 23
pedal_score = 0
instructor_feedback_gpt_accurate = 5
instructor_feedback_gpt_concise = 4
instructor_feedback_gpt_clear = 5
instructor_feedback_gpt_jargon = 2
instructor_feedback_gpt_sentiment = 5
instructor_feedback_pedal_accurate = 3
instructor_feedback_pedal_concise = 4
instructor_feedback_pedal_clear = 1
instructor_feedback_pedal_jargon = 5
instructor_feedback_pedal_sentiment = 3

[bakery_functions_flow_code_timely_extraction.Lapras_20074571.py]
student_code = 
	from bakery import assert_equal
	
	def is_morning(hour: int) -> bool:
	    def is_before_noon(hour: int) -> bool:
	    return hour <= 12    
	    def is_past_dawn(hour: int) -> bool:
	    return hour >= 5
	
	
	
	
	
	assert_equal(is_morning(1), False)
	assert_equal(is_morning(6), True)
	assert_equal(is_morning(11), True)
	assert_equal(is_morning(14), False)
gpt_feedback = Good job in creating the helper functions! Now, your task is to complete the is_morning function to use those helper functions. The is_morning function should return true if the given hour is both past dawn and before noon, according to your helper functions. You can do this using logical 'and' operator between the results of your helper functions. Don't forget to indent the code correctly within the is_morning function scope.
gpt_feedback_length = 70
gpt_score = 0.0
pedal_feedback = Bad indentation on line 5 or adjacent line.
	
	The traceback was:
	<div class='pedal-traceback'>Line 5 of file <code class='pedal-filename'>C:\Users\johna\Documents\pedal-kennel\examples\chosen_problems_st3-3_as3-3_at1_v1/bakery_functions_flow_code_timely_extraction/submissions/Lapras_20074571.py</code>
	<pre class='pedal-python-code python'><code>    return hour <= 12    
	    ^</code></pre>
	</div>
	Expected an indented block after function definition on line 4.
	Suggestion: Check line 5, the line before it, and the line after it. Ignore blank lines.
pedal_feedback_length = 57
pedal_score = 0
instructor_feedback_gpt_accurate = 5
instructor_feedback_gpt_concise = 3
instructor_feedback_gpt_clear = 4
instructor_feedback_gpt_jargon = 4
instructor_feedback_gpt_sentiment = 5
instructor_feedback_pedal_accurate = 3
instructor_feedback_pedal_concise = 2
instructor_feedback_pedal_clear = 1
instructor_feedback_pedal_jargon = 5
instructor_feedback_pedal_sentiment = 3

[bakery_functions_flow_code_timely_extraction.Liepard_19874187.py]
student_code = 
	from cisc108 import assert_equal
	
	def is_before_noon(hour: int) -> bool:
	    return hour <= 12
	
	def is_past_dawn(hour: int) -> bool:
	    return hour >= 5
	
	def is_morning(hour: int) -> bool:
	    return is_past_dawn(hour) and is_before_noon(hour)
	
	assert_equal(is_morning(1), False)
	assert_equal(is_morning(6), True)
	assert_equal(is_morning(11), True)
	assert_equal(is_morning(14), False)
gpt_feedback = Your function is correct! It checks if the time is past dawn and before noon, correctly identifying whether the hour is in the morning. Good use of and operator in your condition. Failing either condition correctly makes is_morning return False.
gpt_feedback_length = 40
gpt_score = 0.0
pedal_feedback = I ran your code.
	
	A ModuleNotFoundError occurred:
	
	<pre class='pedal-exception'>No module named 'cisc108'</pre>
	
	The traceback was:
	<div class='pedal-traceback'>Line 1 of file <code class='pedal-filename'>C:\Users\johna\Documents\pedal-kennel\examples\chosen_problems_st3-3_as3-3_at1_v1/bakery_functions_flow_code_timely_extraction/submissions/Liepard_19874187.py</code>
	<pre class='pedal-python-code python'><code>from cisc108 import assert_equal
	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</code></pre>
	</div>
pedal_feedback_length = 23
pedal_score = 0
instructor_feedback_gpt_accurate = 5
instructor_feedback_gpt_concise = 3
instructor_feedback_gpt_clear = 5
instructor_feedback_gpt_jargon = 4
instructor_feedback_gpt_sentiment = 5
instructor_feedback_pedal_accurate = 3
instructor_feedback_pedal_concise = 4
instructor_feedback_pedal_clear = 1
instructor_feedback_pedal_jargon = 5
instructor_feedback_pedal_sentiment = 3

[bakery_functions_flow_code_timely_extraction.Nosepass_19326157.py]
student_code = 
	from cisc108 import assert_equal
	
	def is_before_noon(hour: int) -> bool:
	    return hour <= 12
	
	def is_past_dawn(hour: int) -> bool:
	    return hour >= 5
	
	def is_morning(hour: int) -> bool:
	    return is_past_dawn or is_before_noon
	
	assert_equal(is_morning(1), False)
	assert_equal(is_morning(6), True)
	assert_equal(is_morning(11), True)
	assert_equal(is_morning(14), False)
gpt_feedback = In the is_morning function, you are currently returning the functions themselves (i.e., is_past_dawn or is_before_noon), rather than calling the functions with the hour parameter. Remember to use parentheses when calling a function.
gpt_feedback_length = 32
gpt_score = 0.0
pedal_feedback = The variable <code class='pedal-name'>hour</code> was given a value on line 9, but was never used after that.
pedal_feedback_length = 17
pedal_score = 0
instructor_feedback_gpt_accurate = 5
instructor_feedback_gpt_concise = 4
instructor_feedback_gpt_clear = 4
instructor_feedback_gpt_jargon = 4
instructor_feedback_gpt_sentiment = 4
instructor_feedback_pedal_accurate = 3
instructor_feedback_pedal_concise = 4
instructor_feedback_pedal_clear = 2
instructor_feedback_pedal_jargon = 4
instructor_feedback_pedal_sentiment = 3

[bakery_functions_flow_code_timely_extraction.Nuzleaf_25659450.py]
student_code = 
	from bakery import assert_equal
	
	def is_before_noon(hour: int) -> bool:
	    return hour <= 12
	
	def is_past_dawn(hour: int) -> bool:
	    return hour >= 5
	
	def is_morning(hour: int) -> bool:
	    return is_before_noon or is_past_dawn
	
	assert_equal(is_morning(1), False)
	assert_equal(is_morning(6), True)
	assert_equal(is_morning(11), True)
	assert_equal(is_morning(14), False)
gpt_feedback = You're on the right track with framing the problem in terms of checking if the time is before noon and after dawn, but there's a small mistake in your code. In your is_morning function, you are returning the function name ('is_before_noon' or 'is_past_dawn') when comparing the hour. Instead, you should call these functions with the hour as a parameter. Use them in such a way that you are not only checking if the hour is less than or equal to 12 but also the hour is greater than or equal to 5.
gpt_feedback_length = 92
gpt_score = 0.0
pedal_feedback = The variable <code class='pedal-name'>hour</code> was given a value on line 9, but was never used after that.
pedal_feedback_length = 17
pedal_score = 0
instructor_feedback_gpt_accurate = 5
instructor_feedback_gpt_concise = 3
instructor_feedback_gpt_clear = 5
instructor_feedback_gpt_jargon = 4
instructor_feedback_gpt_sentiment = 4
instructor_feedback_pedal_accurate = 3
instructor_feedback_pedal_concise = 4
instructor_feedback_pedal_clear = 2
instructor_feedback_pedal_jargon = 4
instructor_feedback_pedal_sentiment = 3

[bakery_if_patterns_make_pig_latin]
description = Define a function `make_pig_latin` that consumes a word (a string) and converts it to actual pig latin (also a string). If the first letter of the word is a vowel, just return that word with `"ay"` added to the end. Otherwise, take the first character of the word and move it to the end of the string, and *then* add `"ay"` to the end. Do not worry about capitalization. If the empty string is given, return `"ay"`.

[bakery_if_patterns_make_pig_latin.Beedrill_21205343.py]
student_code = 
	def make_pig_latin(word: str) -> str:
	    if word[0].lower() in "aeiou":
	        return word + "ay"
	    else:
	        return word[1:] + word[0] + "ay"
	
	print("TEST PASSED")
	print("TEST PASSED")
	print("TEST PASSED")
gpt_feedback = Your code seems to be correct for handling words that are not empty. However, you haven't handled the case where an empty string is entered. Remember that the problem specification asks you to return 'ay' if an empty string is given. You can use an if condition to check if the word is empty and return 'ay' directly in this case. Also, remember to write test cases to ensure your code works as expected.
gpt_feedback_length = 74
gpt_score = 0.0
pedal_feedback = The function <code class='pedal-name'>make_pig_latin</code> was given a definition on line 1, but was never used after that.
pedal_feedback_length = 17
pedal_score = 0
instructor_feedback_gpt_accurate = 5
instructor_feedback_gpt_concise = 5
instructor_feedback_gpt_clear = 5
instructor_feedback_gpt_jargon = 3
instructor_feedback_gpt_sentiment = 4
instructor_feedback_pedal_accurate = 3
instructor_feedback_pedal_concise = 4
instructor_feedback_pedal_clear = 2
instructor_feedback_pedal_jargon = 4
instructor_feedback_pedal_sentiment = 3

[bakery_if_patterns_make_pig_latin.Buizel_22898628.py]
student_code = 
	from cisc108 import assert_equal
	
	def make_pig_latin(word: str) -> str:
	    if word[0] in "AEIOUaeiou"
	        return word + "ay"
gpt_feedback = There seems to be a syntax error. We need to have a colon at the end of the `if` statement to indicate the beginning of the code that gets executed when the condition is `True`. Add a `:` at the end of your `if` condition and try again.
gpt_feedback_length = 48
gpt_score = 0.0
pedal_feedback = Bad syntax on line 4.
	
	The traceback was:
	<div class='pedal-traceback'>Line 4 of file <code class='pedal-filename'>C:\Users\johna\Documents\pedal-kennel\examples\chosen_problems_st3-3_as3-3_at1_v1/bakery_if_patterns_make_pig_latin/submissions/Buizel_22898628.py</code>
	<pre class='pedal-python-code python'><code>    if word[0] in "AEIOUaeiou"
	                              ^</code></pre>
	</div>
	Expected ':'.
	Suggestion: Check line 4, the line before it, and the line after it. Ignore blank lines.
pedal_feedback_length = 68
pedal_score = 0
instructor_feedback_gpt_accurate = 5
instructor_feedback_gpt_concise = 4
instructor_feedback_gpt_clear = 5
instructor_feedback_gpt_jargon = 3
instructor_feedback_gpt_sentiment = 5
instructor_feedback_pedal_accurate = 3
instructor_feedback_pedal_concise = 2
instructor_feedback_pedal_clear = 1
instructor_feedback_pedal_jargon = 5
instructor_feedback_pedal_sentiment = 3

[bakery_if_patterns_make_pig_latin.Darumaka_23539066.py]
student_code = 
	vowel=a
	
	def make_pig_latin (word:str)->str:
	    if word [:0] vowel
	    return word+"ay"
	#else:
	#    return wor
gpt_feedback = You nearly have the right idea! However, your syntax in the if statement is incorrect. Right now, it looks like `if word [:0] vowel`. You're probably trying to check if the first letter of the word is in the vowels. In python, you can use the `in` keyword to do that. Changes:
	
	1. It should be `if word[0] in vowel:` (notice the colon at the end as well)
	2. Don't forget to complete the else part of the code for words that start with a letter other than vowels.
	3. And in python to slice the first character you may want to use [1:] instead of :0.
	4. Last but not least, consider properly defining `vowel` as a list or string of vowels, so that the 'in' operation works as expected.
gpt_feedback_length = 127
gpt_score = 0.0
pedal_feedback = Bad syntax on line 4.
	
	The traceback was:
	<div class='pedal-traceback'>Line 4 of file <code class='pedal-filename'>C:\Users\johna\Documents\pedal-kennel\examples\chosen_problems_st3-3_as3-3_at1_v1/bakery_if_patterns_make_pig_latin/submissions/Darumaka_23539066.py</code>
	<pre class='pedal-python-code python'><code>    if word [:0] vowel
	                 ^</code></pre>
	</div>
	Invalid syntax.
	Suggestion: Check line 4, the line before it, and the line after it. Ignore blank lines.
pedal_feedback_length = 55
pedal_score = 0
instructor_feedback_gpt_accurate = 5
instructor_feedback_gpt_concise = 1
instructor_feedback_gpt_clear = 5
instructor_feedback_gpt_jargon = 4
instructor_feedback_gpt_sentiment = 5
instructor_feedback_pedal_accurate = 5
instructor_feedback_pedal_concise = 2
instructor_feedback_pedal_clear = 1
instructor_feedback_pedal_jargon = 5
instructor_feedback_pedal_sentiment = 3

[bakery_if_patterns_make_pig_latin.Elgyem_20565700.py]
student_code = 
	from cisc108 import assert_equal
	def make_pig_latin(word:str)->str:
	     if word[0].lower()in "aeiou"
	        return word+"ay"
	    else
	        return word[1:]+word[0]+"ay"
	        
	assert_equal(make_pig_latin(word),ordway)
gpt_feedback = Looks like you're on the right track! But there are a couple issues to fix. First, your if and else statements are missing colons at the end. Python requires a colon at the end of each condition in an if-else block. Also, it looks like you are trying to test your function with incorrect parameters. In the test case (`assert_equal(make_pig_latin(word),ordway)`), 'word' and 'ordway' are supposed to be the input and expected output, respectively. So they should be replaced with actual strings or variables that hold string values. Lastly, ensure you handle the case where the input string is empty as per the problem statement.
gpt_feedback_length = 104
gpt_score = 0.0
pedal_feedback = Bad syntax on line 3.
	
	The traceback was:
	<div class='pedal-traceback'>Line 3 of file <code class='pedal-filename'>C:\Users\johna\Documents\pedal-kennel\examples\chosen_problems_st3-3_as3-3_at1_v1/bakery_if_patterns_make_pig_latin/submissions/Elgyem_20565700.py</code>
	<pre class='pedal-python-code python'><code>     if word[0].lower()in "aeiou"
	                                 ^</code></pre>
	</div>
	Expected ':'.
	Suggestion: Check line 3, the line before it, and the line after it. Ignore blank lines.
pedal_feedback_length = 71
pedal_score = 0
instructor_feedback_gpt_accurate = 5
instructor_feedback_gpt_concise = 3
instructor_feedback_gpt_clear = 5
instructor_feedback_gpt_jargon = 4
instructor_feedback_gpt_sentiment = 3
instructor_feedback_pedal_accurate = 5
instructor_feedback_pedal_concise = 2
instructor_feedback_pedal_clear = 1
instructor_feedback_pedal_jargon = 5
instructor_feedback_pedal_sentiment = 3

[bakery_if_patterns_make_pig_latin.Girafarig_21526564.py]
student_code = 
	from cisc108 import assert_equal
	
	def make_pig_latin(word: str) -> str:
	    if word[0] in 'aeiou':
	        return word + 'ay'
	    return word[1:] + word[0] + 'ay'
	
	assert_equal(make_pig_latin("hello"), "elloay")
	assert_equal(make_pig_latin("arugula"), "arugulaay")
	assert_equal(make_pig_latin("potato"), "otatopay")
	assert_equal(make_pig_latin("green"), "reengay")
gpt_feedback = Your code looks great, but you've missed an edge case. Your code will throw an error if it's called with an empty string as the argument because 'word[0]' will be out of range. Remember, the problem statement wants you to return 'ay' if an empty string is given. You should add a condition to check if the string is empty at the beginning of your function.
gpt_feedback_length = 66
gpt_score = 0.0
pedal_feedback = I ran your code.
	
	A ModuleNotFoundError occurred:
	
	<pre class='pedal-exception'>No module named 'cisc108'</pre>
	
	The traceback was:
	<div class='pedal-traceback'>Line 1 of file <code class='pedal-filename'>C:\Users\johna\Documents\pedal-kennel\examples\chosen_problems_st3-3_as3-3_at1_v1/bakery_if_patterns_make_pig_latin/submissions/Girafarig_21526564.py</code>
	<pre class='pedal-python-code python'><code>from cisc108 import assert_equal
	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</code></pre>
	</div>
pedal_feedback_length = 23
pedal_score = 0
instructor_feedback_gpt_accurate = 5
instructor_feedback_gpt_concise = 3
instructor_feedback_gpt_clear = 5
instructor_feedback_gpt_jargon = 3
instructor_feedback_gpt_sentiment = 4
instructor_feedback_pedal_accurate = 3
instructor_feedback_pedal_concise = 4
instructor_feedback_pedal_clear = 1
instructor_feedback_pedal_jargon = 5
instructor_feedback_pedal_sentiment = 3

[bakery_if_patterns_make_pig_latin.Lapras_21931235.py]
student_code = 
	from bakery import assert_equal
	def make_pig_latin(Word:str)->str:
	    if Word[0] in "aeiouAEIOU":
	        pig_latin = Word + "ay"
	    elif Word[0] not in "aeiouAEIOU" and "":
	        pig_latin = Word[1:] + Word[0] +"ay"
	    else:
	            pig_latin = "ay"
	    return pig_latin
	
	assert_equal(make_pig_latin("Fiammetta"), "iamettaFay")       
	assert_equal(make_pig_latin(""), "ay")
	assert_equal(make_pig_latin("Exusiai"), "Exusiaiay")
gpt_feedback = Your code seems mostly correct but it fails to handle an empty string input correctly. The issue seems to be on the line where you're trying to check if the first character of the input string exists within a sequence of vowels. This causes an "IndexError" for an empty string because there's no first character. To fix this, you should first check if the string is empty before trying to access its characters
gpt_feedback_length = 73
gpt_score = 0.0
pedal_feedback = I ran your code.
	
	An IndexError occurred:
	
	<pre class='pedal-exception'>String index out of range</pre>
	
	The traceback was:
	<div class='pedal-traceback'>Line 12 of file <code class='pedal-filename'>C:\Users\johna\Documents\pedal-kennel\examples\chosen_problems_st3-3_as3-3_at1_v1/bakery_if_patterns_make_pig_latin/submissions/Lapras_21931235.py</code>
	<pre class='pedal-python-code python'><code>assert_equal(make_pig_latin(""), "ay")
	             ^^^^^^^^^^^^^^^^^^</code></pre>
	
	Line 3 of file <code class='pedal-filename'>C:\Users\johna\Documents\pedal-kennel\examples\chosen_problems_st3-3_as3-3_at1_v1/bakery_if_patterns_make_pig_latin/submissions/Lapras_21931235.py</code> in <code class='pedal-frame'>make_pig_latin</code>
	<pre class='pedal-python-code python'><code>    if Word[0] in "aeiouAEIOU":
	       ^^^^^^^</code></pre>
	</div>
	An IndexError means that you indexed past the end of a string or a list.  For example, if you access index 5 in a list with 3 items.
	
	Suggestion: Remember that the first position in a list or string is 0. Often, you will be off by just one index position, so check your math. Also, make sure the list or string has the right value.
pedal_feedback_length = 124
pedal_score = 0
instructor_feedback_gpt_accurate = 4
instructor_feedback_gpt_concise = 3
instructor_feedback_gpt_clear = 5
instructor_feedback_gpt_jargon = 4
instructor_feedback_gpt_sentiment = 4
instructor_feedback_pedal_accurate = 3
instructor_feedback_pedal_concise = 1
instructor_feedback_pedal_clear = 1
instructor_feedback_pedal_jargon = 5
instructor_feedback_pedal_sentiment = 3

[bakery_if_patterns_make_pig_latin.Liepard_21631305.py]
student_code = 
	from cisc108 import assert_equal
	
	def make_pig_latin(word: str) -> str:
	    if word[0] in "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ":
	        return word + "ay"
gpt_feedback = You are checking if the first letter of the word is a letter which is not what the problem asks for. Instead, you should check if the first letter of the word is a vowel (a, e, i, o, or u). If it is, then you should add 'ay' to the end of the word. If it is not a vowel, you should move the first letter to the end of the word and then add 'ay' to the end.
gpt_feedback_length = 80
gpt_score = 0.0
pedal_feedback = The function <code class='pedal-name'>assert_equal</code> was given a definition on line 1, but was never used after that.
pedal_feedback_length = 17
pedal_score = 0
instructor_feedback_gpt_accurate = 4
instructor_feedback_gpt_concise = 3
instructor_feedback_gpt_clear = 4
instructor_feedback_gpt_jargon = 3
instructor_feedback_gpt_sentiment = 3
instructor_feedback_pedal_accurate = 3
instructor_feedback_pedal_concise = 4
instructor_feedback_pedal_clear = 2
instructor_feedback_pedal_jargon = 4
instructor_feedback_pedal_sentiment = 3

[bakery_if_patterns_make_pig_latin.Nosepass_22110513.py]
student_code = 
	from cisc108 import assert_equal
	
	def make_pig_latin(word: str)->str:
	    vowels = ["A","E","I","O","U"]
	    if not word:
	        return "ay"
	    elif word[0].upper() in vowels:
	        return word + "ay"
	    return word[1:] + word[0] + "ay"
	
	assertequal(make_pig_latin(""),"ay")
	assertequal(make_pig_latin("effort"),"effortay")
	assertequal(make_pig_latin("make"),"akemay")
	assertequal(make_pig_latin("word"),"ordway")
	assertequal(make_pig_latin("award"),"awarday")
gpt_feedback = You're almost there! It seems like there might be a small typo in your function calls to `assert_equal`. You have written `assertequal` instead of `assert_equal`. Python is case sensitive and every character including underscores (_) matter.
gpt_feedback_length = 36
gpt_score = 0.0
pedal_feedback = The variable <code class='pedal-name'>assertequal</code> was used on line 11, but it was not given a value on a previous line. You cannot use a variable until it has been given a value.
pedal_feedback_length = 32
pedal_score = 0
instructor_feedback_gpt_accurate = 5
instructor_feedback_gpt_concise = 5
instructor_feedback_gpt_clear = 5
instructor_feedback_gpt_jargon = 4
instructor_feedback_gpt_sentiment = 5
instructor_feedback_pedal_accurate = 3
instructor_feedback_pedal_concise = 4
instructor_feedback_pedal_clear = 2
instructor_feedback_pedal_jargon = 4
instructor_feedback_pedal_sentiment = 3

[bakery_if_patterns_make_pig_latin.Nuzleaf_27538944.py]
student_code = 
	from cisc108 import assert_equal
	
	def make_pig_latin(word:str)->str:
	    if word==""
	        return "ay"
	    elif word[0] in "aeiou":
	        return word+"ay"
	    else:
	        return word[1:]+word[0]+"ay"
gpt_feedback = You have a missing colon after your first if condition. In Python, you need a colon at the end of your condition when defining an if, elif or else structure to denote the start of the code block. The correct code should be `if word == "":`. Please correct it and try executing the function again.
gpt_feedback_length = 56
gpt_score = 0.0
pedal_feedback = Bad syntax on line 4.
	
	The traceback was:
	<div class='pedal-traceback'>Line 4 of file <code class='pedal-filename'>C:\Users\johna\Documents\pedal-kennel\examples\chosen_problems_st3-3_as3-3_at1_v1/bakery_if_patterns_make_pig_latin/submissions/Nuzleaf_27538944.py</code>
	<pre class='pedal-python-code python'><code>    if word==""
	               ^</code></pre>
	</div>
	Expected ':'.
	Suggestion: Check line 4, the line before it, and the line after it. Ignore blank lines.
pedal_feedback_length = 51
pedal_score = 0
instructor_feedback_gpt_accurate = 5
instructor_feedback_gpt_concise = 4
instructor_feedback_gpt_clear = 5
instructor_feedback_gpt_jargon = 4
instructor_feedback_gpt_sentiment = 3
instructor_feedback_pedal_accurate = 5
instructor_feedback_pedal_concise = 3
instructor_feedback_pedal_clear = 1
instructor_feedback_pedal_jargon = 5
instructor_feedback_pedal_sentiment = 3

[bakery_intro_import_code_import_variable]
description = The file `my_second_module.py` is available to be imported into your program, and contains a string variable named `art`. Import the variable from the module, and print its contents.

[bakery_intro_import_code_import_variable.Beedrill_16150346.py]
student_code = 
	import art from my_second_module
gpt_feedback = In Python, the correct syntax to import a specific variable from a module is 'from module import variable'. You might want to correct your import statement.
gpt_feedback_length = 26
gpt_score = 0.0
pedal_feedback = Bad syntax on line 1.
	
	The traceback was:
	<div class='pedal-traceback'>Line 1 of file <code class='pedal-filename'>C:\Users\johna\Documents\pedal-kennel\examples\chosen_problems_st3-3_as3-3_at1_v1/bakery_intro_import_code_import_variable/submissions/Beedrill_16150346.py</code>
	<pre class='pedal-python-code python'><code>import art from my_second_module
	           ^</code></pre>
	</div>
	Invalid syntax.
	Suggestion: Check line 1, the line before it, and the line after it. Ignore blank lines.
pedal_feedback_length = 45
pedal_score = 0
instructor_feedback_gpt_accurate = 5
instructor_feedback_gpt_concise = 5
instructor_feedback_gpt_clear = 5
instructor_feedback_gpt_jargon = 3
instructor_feedback_gpt_sentiment = 3
instructor_feedback_pedal_accurate = 5
instructor_feedback_pedal_concise = 3
instructor_feedback_pedal_clear = 1
instructor_feedback_pedal_jargon = 5
instructor_feedback_pedal_sentiment = 3

[bakery_intro_import_code_import_variable.Buizel_17811305.py]
student_code = 
	from my_second_module.py import art
gpt_feedback = In Python, when importing from a module, we don't include the '.py' in the module name. Try again, but this time just use 'my_second_module' when using the import statement.
gpt_feedback_length = 29
gpt_score = 0.0
pedal_feedback = You should not have the `.py` part of the filename in your `import` statement. Only use the name of the module on its own!
pedal_feedback_length = 24
pedal_score = 0
instructor_feedback_gpt_accurate = 5
instructor_feedback_gpt_concise = 5
instructor_feedback_gpt_clear = 5
instructor_feedback_gpt_jargon = 2
instructor_feedback_gpt_sentiment = 4
instructor_feedback_pedal_accurate = 5
instructor_feedback_pedal_concise = 5
instructor_feedback_pedal_clear = 4
instructor_feedback_pedal_jargon = 2
instructor_feedback_pedal_sentiment = 3

[bakery_intro_import_code_import_variable.Darumaka_17744727.py]
student_code = 
	art = """
	
	
	
	
	
	\|/
	
	
	
	_
	print(""")
gpt_feedback = You've printed the string variable but you haven't imported it from the `my_second_module.py` file yet. You use the import keyword for importing a module in Python. If you only want to import a specific part of a module, you can use the `from` and `import` keywords in combination.
gpt_feedback_length = 48
gpt_score = 0.0
pedal_feedback = Bad syntax on line 12.
	
	The traceback was:
	<div class='pedal-traceback'>Line 12 of file <code class='pedal-filename'>C:\Users\johna\Documents\pedal-kennel\examples\chosen_problems_st3-3_as3-3_at1_v1/bakery_intro_import_code_import_variable/submissions/Darumaka_17744727.py</code>
	<pre class='pedal-python-code python'><code>print(""")
	         ^</code></pre>
	</div>
	Unmatched ')'.
	Suggestion: Check line 12, the line before it, and the line after it. Ignore blank lines.
pedal_feedback_length = 40
pedal_score = 0
instructor_feedback_gpt_accurate = 4
instructor_feedback_gpt_concise = 3
instructor_feedback_gpt_clear = 5
instructor_feedback_gpt_jargon = 3
instructor_feedback_gpt_sentiment = 3
instructor_feedback_pedal_accurate = 5
instructor_feedback_pedal_concise = 3
instructor_feedback_pedal_clear = 1
instructor_feedback_pedal_jargon = 5
instructor_feedback_pedal_sentiment = 3

[bakery_intro_import_code_import_variable.Elgyem_16229137.py]
student_code = 
	import file
	
	print("art",my_second_module.py)
gpt_feedback = There are two things to correct. First, you're trying to import 'file' which is not what you need. You should be importing the specific module 'my_second_module'. Secondly, when you're trying to print something from a module, you don't need to include '.py'. Instead, you should format it as 'module.variable'. Replace your code with: 'import my_second_module' and 'print(my_second_module.art)'.
gpt_feedback_length = 57
gpt_score = 0.0
pedal_feedback = You should not have the `.py` part of the filename in your `import` statement. Only use the name of the module on its own!
pedal_feedback_length = 24
pedal_score = 0
instructor_feedback_gpt_accurate = 5
instructor_feedback_gpt_concise = 2
instructor_feedback_gpt_clear = 5
instructor_feedback_gpt_jargon = 2
instructor_feedback_gpt_sentiment = 2
instructor_feedback_pedal_accurate = 5
instructor_feedback_pedal_concise = 5
instructor_feedback_pedal_clear = 3
instructor_feedback_pedal_jargon = 2
instructor_feedback_pedal_sentiment = 3

[bakery_intro_import_code_import_variable.Girafarig_18042275.py]
student_code = 
	from my_secon_module import art
	print(art)
gpt_feedback = It seems like you made a typo while importing the module. The correct module name is `my_second_module`, not `my_secon_module`. Please correct it.
gpt_feedback_length = 22
gpt_score = 0.0
pedal_feedback = I ran your code.
	
	A ModuleNotFoundError occurred:
	
	<pre class='pedal-exception'>No module named 'my_secon_module'</pre>
	
	The traceback was:
	<div class='pedal-traceback'>Line 1 of file <code class='pedal-filename'>C:\Users\johna\Documents\pedal-kennel\examples\chosen_problems_st3-3_as3-3_at1_v1/bakery_intro_import_code_import_variable/submissions/Girafarig_18042275.py</code>
	<pre class='pedal-python-code python'><code>from my_secon_module import art
	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</code></pre>
	</div>
pedal_feedback_length = 23
pedal_score = 0
instructor_feedback_gpt_accurate = 5
instructor_feedback_gpt_concise = 5
instructor_feedback_gpt_clear = 4
instructor_feedback_gpt_jargon = 3
instructor_feedback_gpt_sentiment = 3
instructor_feedback_pedal_accurate = 3
instructor_feedback_pedal_concise = 4
instructor_feedback_pedal_clear = 1
instructor_feedback_pedal_jargon = 5
instructor_feedback_pedal_sentiment = 3

[bakery_intro_import_code_import_variable.Lapras_17636639.py]
student_code = 
	import my_second_module.py 
	print (art)
gpt_feedback = There's just a slight mistake in your code. In Python, when importing a module you don't need to include the `.py` extension, just the module name alone. Also, to access a variable from a module, you should use dot notation and write the module's name first. So, instead of `print(art)`, you should write `print(my_second_module.art)`.
gpt_feedback_length = 54
gpt_score = 0.0
pedal_feedback = You should not have the `.py` part of the filename in your `import` statement. Only use the name of the module on its own!
pedal_feedback_length = 24
pedal_score = 0
instructor_feedback_gpt_accurate = 5
instructor_feedback_gpt_concise = 4
instructor_feedback_gpt_clear = 5
instructor_feedback_gpt_jargon = 3
instructor_feedback_gpt_sentiment = 4
instructor_feedback_pedal_accurate = 5
instructor_feedback_pedal_concise = 5
instructor_feedback_pedal_clear = 3
instructor_feedback_pedal_jargon = 2
instructor_feedback_pedal_sentiment = 3

[bakery_intro_import_code_import_variable.Liepard_18047518.py]
student_code = 
	from my_second_module.py import art
	print(art)
gpt_feedback = Almost there! When you import from a module in Python, you typically shouldn't include the '.py' extension. Try modifying your import statement to `from my_second_module import art`.
gpt_feedback_length = 27
gpt_score = 0.0
pedal_feedback = You should not have the `.py` part of the filename in your `import` statement. Only use the name of the module on its own!
pedal_feedback_length = 24
pedal_score = 0
instructor_feedback_gpt_accurate = 5
instructor_feedback_gpt_concise = 5
instructor_feedback_gpt_clear = 5
instructor_feedback_gpt_jargon = 3
instructor_feedback_gpt_sentiment = 4
instructor_feedback_pedal_accurate = 5
instructor_feedback_pedal_concise = 5
instructor_feedback_pedal_clear = 3
instructor_feedback_pedal_jargon = 2
instructor_feedback_pedal_sentiment = 3

[bakery_intro_import_code_import_variable.Nosepass_16621124.py]
student_code = 
	import my_second_module.py
	print(art)
gpt_feedback = Almost there! When importing a module in Python, you only need to give the name of the module, not the '.py' file extension. Also, since 'art' is a variable from another module, you need to reference it with the module's name. Try using `my_second_module.art` instead of just `art`.
gpt_feedback_length = 48
gpt_score = 0.0
pedal_feedback = You should not have the `.py` part of the filename in your `import` statement. Only use the name of the module on its own!
pedal_feedback_length = 24
pedal_score = 0
instructor_feedback_gpt_accurate = 5
instructor_feedback_gpt_concise = 4
instructor_feedback_gpt_clear = 5
instructor_feedback_gpt_jargon = 2
instructor_feedback_gpt_sentiment = 4
instructor_feedback_pedal_accurate = 5
instructor_feedback_pedal_concise = 5
instructor_feedback_pedal_clear = 3
instructor_feedback_pedal_jargon = 2
instructor_feedback_pedal_sentiment = 3

[bakery_intro_import_code_import_variable.Nuzleaf_22980678.py]
student_code = 
	from my_second_module.py import art
	print (art)
gpt_feedback = Remember, when you are importing a Python module, you don't need to include the '.py' extension. Try again without it.
gpt_feedback_length = 20
gpt_score = 0.0
pedal_feedback = You should not have the `.py` part of the filename in your `import` statement. Only use the name of the module on its own!
pedal_feedback_length = 24
pedal_score = 0
instructor_feedback_gpt_accurate = 5
instructor_feedback_gpt_concise = 5
instructor_feedback_gpt_clear = 5
instructor_feedback_gpt_jargon = 1
instructor_feedback_gpt_sentiment = 3
instructor_feedback_pedal_accurate = 5
instructor_feedback_pedal_concise = 5
instructor_feedback_pedal_clear = 3
instructor_feedback_pedal_jargon = 2
instructor_feedback_pedal_sentiment = 3

[bakery_intro_programs_code_try_blockpy]
description = Hello, and welcome to BlockPy! This tool will let you write and run  Python code.
	
	Below, you can see the code editor where there is already a bit of code.
	
	Click the green "Run" button to see the result of running your  code in the "Console" and "Feedback" areas.
	
	When you see the green "Complete" box, you've completed this problem!

[bakery_intro_programs_code_try_blockpy.Beedrill_15803943.py]
student_code = 
	print("Welcome to BlockPy!")
gpt_feedback = Your print statement looks fine. It should output the string 'Welcome to BlockPy!' correctly. Remember, in Python, the print() function is used to output data to the standard output device (the screen). Keep going!
gpt_feedback_length = 34
gpt_score = 0.0
pedal_feedback = Great work!
pedal_feedback_length = 2
pedal_score = 1
instructor_feedback_gpt_accurate = 5
instructor_feedback_gpt_concise = 3
instructor_feedback_gpt_clear = 5
instructor_feedback_gpt_jargon = 1
instructor_feedback_gpt_sentiment = 5
instructor_feedback_pedal_accurate = 5
instructor_feedback_pedal_concise = 5
instructor_feedback_pedal_clear = 5
instructor_feedback_pedal_jargon = 1
instructor_feedback_pedal_sentiment = 5

[bakery_intro_programs_code_try_blockpy.Buizel_16401118.py]
student_code = 
	print("Welcome to BlockPy!")
gpt_feedback = Great job! Your print statement works perfectly. It prints the message 'Welcome to BlockPy!' on the console.
gpt_feedback_length = 17
gpt_score = 0.0
pedal_feedback = Great work!
pedal_feedback_length = 2
pedal_score = 1
instructor_feedback_gpt_accurate = 5
instructor_feedback_gpt_concise = 5
instructor_feedback_gpt_clear = 5
instructor_feedback_gpt_jargon = 1
instructor_feedback_gpt_sentiment = 5
instructor_feedback_pedal_accurate = 5
instructor_feedback_pedal_concise = 5
instructor_feedback_pedal_clear = 5
instructor_feedback_pedal_jargon = 1
instructor_feedback_pedal_sentiment = 5

[bakery_intro_programs_code_try_blockpy.Darumaka_16967377.py]
student_code = 
	print("Welcome to BlockPy!")
gpt_feedback = Great! Your code looks good. It will print 'Welcome to BlockPy!' when run. Remember that you can print any text you want inside the brackets. Just make sure to keep the text within the quotation marks.
gpt_feedback_length = 36
gpt_score = 0.0
pedal_feedback = Great work!
pedal_feedback_length = 2
pedal_score = 1
instructor_feedback_gpt_accurate = 5
instructor_feedback_gpt_concise = 2
instructor_feedback_gpt_clear = 5
instructor_feedback_gpt_jargon = 1
instructor_feedback_gpt_sentiment = 5
instructor_feedback_pedal_accurate = 5
instructor_feedback_pedal_concise = 5
instructor_feedback_pedal_clear = 5
instructor_feedback_pedal_jargon = 1
instructor_feedback_pedal_sentiment = 5

[bakery_intro_programs_code_try_blockpy.Elgyem_15701933.py]
student_code = 
	print("Welcome to BlockPy!")
gpt_feedback = Great job! Your code executed successfully and printed out the intended message. Keep going!
gpt_feedback_length = 14
gpt_score = 0.0
pedal_feedback = Great work!
pedal_feedback_length = 2
pedal_score = 1
instructor_feedback_gpt_accurate = 5
instructor_feedback_gpt_concise = 5
instructor_feedback_gpt_clear = 5
instructor_feedback_gpt_jargon = 1
instructor_feedback_gpt_sentiment = 5
instructor_feedback_pedal_accurate = 5
instructor_feedback_pedal_concise = 5
instructor_feedback_pedal_clear = 5
instructor_feedback_pedal_jargon = 1
instructor_feedback_pedal_sentiment = 5

[bakery_intro_programs_code_try_blockpy.Girafarig_16114772.py]
student_code = 
	print("Welcome to BlockPy!")
gpt_feedback = Great job! Your code ran successfully and printed the welcoming message.
gpt_feedback_length = 11
gpt_score = 0.0
pedal_feedback = Great work!
pedal_feedback_length = 2
pedal_score = 1
instructor_feedback_gpt_accurate = 5
instructor_feedback_gpt_concise = 5
instructor_feedback_gpt_clear = 5
instructor_feedback_gpt_jargon = 1
instructor_feedback_gpt_sentiment = 5
instructor_feedback_pedal_accurate = 5
instructor_feedback_pedal_concise = 5
instructor_feedback_pedal_clear = 5
instructor_feedback_pedal_jargon = 1
instructor_feedback_pedal_sentiment = 5

[bakery_intro_programs_code_try_blockpy.Lapras_16280492.py]
student_code = 
	print("Welcome to BlockPy!")
gpt_feedback = Great job! Your print statement is correct. The string 'Welcome to BlockPy!' will be displayed when the code is run. Continue working on the next task.
gpt_feedback_length = 26
gpt_score = 0.0
pedal_feedback = Great work!
pedal_feedback_length = 2
pedal_score = 1
instructor_feedback_gpt_accurate = 5
instructor_feedback_gpt_concise = 4
instructor_feedback_gpt_clear = 5
instructor_feedback_gpt_jargon = 1
instructor_feedback_gpt_sentiment = 5
instructor_feedback_pedal_accurate = 5
instructor_feedback_pedal_concise = 5
instructor_feedback_pedal_clear = 5
instructor_feedback_pedal_jargon = 1
instructor_feedback_pedal_sentiment = 5

[bakery_intro_programs_code_try_blockpy.Liepard_16523595.py]
student_code = 
	print("Welcome to BlockPy!")
gpt_feedback = Great job! Your print statement is correct and will display the message as expected.
gpt_feedback_length = 14
gpt_score = 0.0
pedal_feedback = Great work!
pedal_feedback_length = 2
pedal_score = 1
instructor_feedback_gpt_accurate = 5
instructor_feedback_gpt_concise = 4
instructor_feedback_gpt_clear = 5
instructor_feedback_gpt_jargon = 1
instructor_feedback_gpt_sentiment = 5
instructor_feedback_pedal_accurate = 5
instructor_feedback_pedal_concise = 5
instructor_feedback_pedal_clear = 5
instructor_feedback_pedal_jargon = 1
instructor_feedback_pedal_sentiment = 5

[bakery_intro_programs_code_try_blockpy.Nosepass_15790367.py]
student_code = 
	print("Welcome to BlockPy!")
gpt_feedback = Great job! Your print statement is correct and will output the text 'Welcome to BlockPy!' when run.
gpt_feedback_length = 17
gpt_score = 0.0
pedal_feedback = Great work!
pedal_feedback_length = 2
pedal_score = 1
instructor_feedback_gpt_accurate = 5
instructor_feedback_gpt_concise = 5
instructor_feedback_gpt_clear = 5
instructor_feedback_gpt_jargon = 1
instructor_feedback_gpt_sentiment = 5
instructor_feedback_pedal_accurate = 5
instructor_feedback_pedal_concise = 5
instructor_feedback_pedal_clear = 5
instructor_feedback_pedal_jargon = 1
instructor_feedback_pedal_sentiment = 5

[bakery_intro_programs_code_try_blockpy.Nuzleaf_22476432.py]
student_code = 
	print("Welcome to BlockPy!")
gpt_feedback = Great job on your first line of code! It looks perfect. When run, your code will print 'Welcome to BlockPy!' to the console.
gpt_feedback_length = 23
gpt_score = 0.0
pedal_feedback = Great work!
pedal_feedback_length = 2
pedal_score = 1
instructor_feedback_gpt_accurate = 5
instructor_feedback_gpt_concise = 4
instructor_feedback_gpt_clear = 5
instructor_feedback_gpt_jargon = 1
instructor_feedback_gpt_sentiment = 5
instructor_feedback_pedal_accurate = 5
instructor_feedback_pedal_concise = 5
instructor_feedback_pedal_clear = 5
instructor_feedback_pedal_jargon = 1
instructor_feedback_pedal_sentiment = 5

[bakery_nesting_list_dataclasses_code_good_job]
description = The dataclass `Job` is defined below with the fields `title` (str), `salary` (int), `available` (boolean), and `company` (str).
	
	Define a function `best_job` that consumes a list of jobs and returns the `Job` with the highest `salary` that is `available`. If no jobs are available, then return the default `UNEMPLOYED` job instead.
	
	You will need to unit test your code a sufficient number of times.
	
	**HINT**: Define a helper function to filter out the unavailable jobs BEFORE you determine the highest salary `Job`. An `if` statement used as a Defensive Guard will be very effective for returning the appropriate value in the case where there are no available guards. Having two helper functions (one to filter available jobs, and one to determine the highest salary) in addition to the main `best_job` function makes this a lot easier to keep track of everything.

[bakery_nesting_list_dataclasses_code_good_job.Beedrill_31352318.py]
student_code = 
	from dataclasses import dataclass
	from bakery import assert_equal
	
	@dataclass
	class Job:
	    title: str
	    salary: int
	    available: bool
	    company: str
	    
	UNEMPLOYED = Job("Unemployed", 0, True, "None")
	
	def best_job(jobs: [Job]) -> Job:
	    if not [job for job in jobs if job.available]:
	        return UNEMPLOYED
	    return max([job for job in jobs if job.available], key=lambda job: job.salary)
gpt_feedback = Your code looks good! You have correctly used list comprehension to filter out the available jobs and then use the max function along with a lambda function to find the job with the highest salary. Remember to write tests now to make sure everything is working as expected. Always test your function with varied data to confirm it behaves as intended.
gpt_feedback_length = 61
gpt_score = 0.0
pedal_feedback = The function <code class='pedal-name'>assert_equal</code> was given a definition on line 2, but was never used after that.
pedal_feedback_length = 17
pedal_score = 0
instructor_feedback_gpt_accurate = 5
instructor_feedback_gpt_concise = 3
instructor_feedback_gpt_clear = 4
instructor_feedback_gpt_jargon = 2
instructor_feedback_gpt_sentiment = 5
instructor_feedback_pedal_accurate = 3
instructor_feedback_pedal_concise = 4
instructor_feedback_pedal_clear = 2
instructor_feedback_pedal_jargon = 4
instructor_feedback_pedal_sentiment = 3

[bakery_nesting_list_dataclasses_code_good_job.Buizel_31739575.py]
student_code = 
	from dataclasses import dataclass
	from bakery import assert_equal
	
	@dataclass
	class Job:
	    title: str
	    salary: int
	    available: bool
	    company: str
	    
	UNEMPLOYED = Job("Unemployed", 0, True, "None")
gpt_feedback = The Job class and the UNEMPLOYED constant are correctly defined. Now, you can start implementing the 'best_job' function. Remember to create two helper functions: one to filter out the unavailable jobs and another one to find the job with the highest salary.
gpt_feedback_length = 42
gpt_score = 0.0
pedal_feedback = The function <code class='pedal-name'>assert_equal</code> was given a definition on line 2, but was never used after that.
pedal_feedback_length = 17
pedal_score = 0
instructor_feedback_gpt_accurate = 5
instructor_feedback_gpt_concise = 5
instructor_feedback_gpt_clear = 5
instructor_feedback_gpt_jargon = 4
instructor_feedback_gpt_sentiment = 5
instructor_feedback_pedal_accurate = 3
instructor_feedback_pedal_concise = 4
instructor_feedback_pedal_clear = 2
instructor_feedback_pedal_jargon = 4
instructor_feedback_pedal_sentiment = 3

[bakery_nesting_list_dataclasses_code_good_job.Darumaka_31747902.py]
student_code = 
	from dataclasses import dataclass
	from bakery import assert_equal
	
	@dataclass
	class Job:
	    title: str
	    salary: int
	    available: bool
	    company: str
	    
	UNEMPLOYED = Job("Unemployed", 0, True, "None")
	
	def available(avail:[Job])->bool:
	    taking = []
	    for avai in avail:
	        if avail.available is True:
	            taking.append(avai)
	    return False
	
	Job1 = [Job("banker", 5, True, "PNC")]
	assert_equal(available(Job1), [Job("banker", 5, True, "PNC")])
gpt_feedback = You are on the right track! However, there is a mistake in the function `available`. The `avail` argument is a list and when you are looping through it, you are getting individual `Job` objects. You should be using `avai.available` instead of `avail.available`. Also, the function should return the list `taking`, not `False`.
gpt_feedback_length = 52
gpt_score = 0.0
pedal_feedback = The variable <code class='pedal-name'>taking</code> was given a value on line 16, but was never used after that.
pedal_feedback_length = 17
pedal_score = 0
instructor_feedback_gpt_accurate = 5
instructor_feedback_gpt_concise = 2
instructor_feedback_gpt_clear = 5
instructor_feedback_gpt_jargon = 3
instructor_feedback_gpt_sentiment = 4
instructor_feedback_pedal_accurate = 3
instructor_feedback_pedal_concise = 4
instructor_feedback_pedal_clear = 2
instructor_feedback_pedal_jargon = 4
instructor_feedback_pedal_sentiment = 3

[bakery_nesting_list_dataclasses_code_good_job.Elgyem_30552172.py]
student_code = 
	from dataclasses import dataclass
	from bakery import assert_equal
	
	@dataclass
	class Job:
	    title: str
	    salary: int
	    available: bool
	    company: str
	    
	def can(have:list[Job])->bool:
	    new_list=[]
	    for h in have:
	        if h.available==True:
	            new_list.append(h)
	    return new_list
	
	def highest(
	    
	UNEMPLOYED = Job("Unemployed", 0, True, "None")
gpt_feedback = It seems like you stopped halfway through. From what I see, you have created a helper method 'can' which filters out the jobs that are unavailable. However, it doesn't return a boolean as its method signature states, instead it returns a list. Now, you need to create another helper method that finds the job with the highest salary from this list of available jobs. Finally, you need to combine these in your main 'best_job' function. Don't forget to check if there are no available jobs, and return the `UNEMPLOYED` job in that case.
gpt_feedback_length = 93
gpt_score = 0.0
pedal_feedback = Bad syntax on line 18.
	
	The traceback was:
	<div class='pedal-traceback'>Line 18 of file <code class='pedal-filename'>C:\Users\johna\Documents\pedal-kennel\examples\chosen_problems_st3-3_as3-3_at1_v1/bakery_nesting_list_dataclasses_code_good_job/submissions/Elgyem_30552172.py</code>
	<pre class='pedal-python-code python'><code>def highest(
	           ^</code></pre>
	</div>
	'(' was never closed.
	Suggestion: Check line 18, the line before it, and the line after it. Ignore blank lines.
pedal_feedback_length = 45
pedal_score = 0
instructor_feedback_gpt_accurate = 5
instructor_feedback_gpt_concise = 2
instructor_feedback_gpt_clear = 5
instructor_feedback_gpt_jargon = 2
instructor_feedback_gpt_sentiment = 4
instructor_feedback_pedal_accurate = 5
instructor_feedback_pedal_concise = 3
instructor_feedback_pedal_clear = 1
instructor_feedback_pedal_jargon = 5
instructor_feedback_pedal_sentiment = 3

[bakery_nesting_list_dataclasses_code_good_job.Girafarig_31362083.py]
student_code = 
	from dataclasses import dataclass
	from bakery import assert_equal
	
	@dataclass
	class Job:
	    title: str
	    salary: int
	    available: bool
	    company: str
	    
	UNEMPLOYED = Job("Unemployed", 0, True, "None")
	
	def best_job(jobs: list[Job]) -> Job:
	    greatest_job = UNEMPLOYED
	    for job in jobs:
	        if job.available:
	            if job.salary > greatest_job.salary:
	                greatest_job = job
	    return greatest_job
	
	
	painter = Job("Painter", 5000, True, "Painers Inc.")
	seamstress = Job("Seamstress", 4000, False, "Sewing and Strings")
	server = Job("waiter", 3500, False, "Bob's")
	
	assert_equal(best_job([painter, seamstress, waiter]), 8500)
	assert_equal(best_job([waiter]), UNEMPLOYED)
	assert_equal(best_job([painter]), 5000)
gpt_feedback = Your logic in the `best_job` function seems correct, but there are some problems in your assertions. When using `assert_equal`, you should compare `best_job([..jobs..])` to a `Job` instance, not a salary. For example, your first assert could be `assert_equal(best_job([painter, seamstress, waiter]), painter)`, because `painter` is the best available job among the three. Also, in the list that you are passing to the `best_job` function in the first assert, a variable `waiter` is used, but it is not defined anywhere. Maybe you meant to use the `server` Job instance instead of `waiter`.
gpt_feedback_length = 90
gpt_score = 0.0
pedal_feedback = The variable <code class='pedal-name'>waiter</code> was used on line 26, but it was not given a value on a previous line. You cannot use a variable until it has been given a value.
pedal_feedback_length = 32
pedal_score = 0
instructor_feedback_gpt_accurate = 5
instructor_feedback_gpt_concise = 1
instructor_feedback_gpt_clear = 5
instructor_feedback_gpt_jargon = 4
instructor_feedback_gpt_sentiment = 4
instructor_feedback_pedal_accurate = 3
instructor_feedback_pedal_concise = 4
instructor_feedback_pedal_clear = 2
instructor_feedback_pedal_jargon = 4
instructor_feedback_pedal_sentiment = 3

[bakery_nesting_list_dataclasses_code_good_job.Lapras_30790908.py]
student_code = 
	from dataclasses import dataclass
	from bakery import assert_equal
	
	@dataclass
	class Job:
	    title: str
	    salary: int
	    available: bool
	    company: str
	    
	UNEMPLOYED = Job("Unemployed", 0, True, "None")
	
	def best_job(jobs:[Job])-> Job:
	    greatest_job = UNEMPLOYED.salary
	    for job in jobs:
	        if job.salary > greatest_job:
	            if job.available:
	                greatest_job = job.salary
	    return greatest_job
	
	jobslist = [Job('Legend', 0, False, 'Earth'),
	            Job('Garbageman', 30_000, True, 'City'),
	            Job('Lawyer', 400_000, False, 'City'),
	            Job('Plumber', 75_000, True, 'City')]
	assert_equal(best_job(jobslist), 75_000)
	assert_equal(best_job([]), 0)
	assert_equalassert_equal(best_job(jobslist[:-1]), 30_000)
gpt_feedback = You're on the right track, but there's a small error in your code. The function `best_job` is expected to return a `Job` object, not just the salary of the job. Make sure that you are assigning the entire job to `greatest_job`, not just the salary. Also, in your assertions, you're supposed to check against Job objects, not salary numbers.
gpt_feedback_length = 59
gpt_score = 0.0
pedal_feedback = Your function returned an integer on line 25, even though you defined it to return A Job. Your function should return values consistently.
pedal_feedback_length = 23
pedal_score = 0
instructor_feedback_gpt_accurate = 5
instructor_feedback_gpt_concise = 4
instructor_feedback_gpt_clear = 4
instructor_feedback_gpt_jargon = 1
instructor_feedback_gpt_sentiment = 4
instructor_feedback_pedal_accurate = 5
instructor_feedback_pedal_concise = 5
instructor_feedback_pedal_clear = 2
instructor_feedback_pedal_jargon = 3
instructor_feedback_pedal_sentiment = 3

[bakery_nesting_list_dataclasses_code_good_job.Liepard_31859101.py]
student_code = 
	from dataclasses import dataclass
	from bakery import assert_equal
	
	@dataclass
	class Job:
	    title: str
	    salary: int
	    available: bool
	    company: str
	    
	UNEMPLOYED = Job("Unemployed", 0, True, "None")
	
	def best_job(jobs: list[Job]) -> Job:
	    highestPay = 0
	    jobTitle = ""
	    for job in jobs:
	        if job.available == False:
	            if job.salary > highestPay:
	                highestPay = job.salary
	                jobTitle = job.title
	    return jobTitle
gpt_feedback = Your code has a logic issue. Currently, your code is checking if the job is not available THEN checking if the salary is greater than the highest salary found so far. Also, your function `best_job` returns just the job title instead of the whole job object. This needs to be corrected. Also, consider implementing the hint in the problem statement about using two helper functions. One to filter available jobs and the other to determine the highest salary job. This will make your `best_job` function simpler and easier to understand.
gpt_feedback_length = 90
gpt_score = 0.0
pedal_feedback = The function <code class='pedal-name'>assert_equal</code> was given a definition on line 2, but was never used after that.
pedal_feedback_length = 17
pedal_score = 0
instructor_feedback_gpt_accurate = 5
instructor_feedback_gpt_concise = 2
instructor_feedback_gpt_clear = 5
instructor_feedback_gpt_jargon = 2
instructor_feedback_gpt_sentiment = 4
instructor_feedback_pedal_accurate = 3
instructor_feedback_pedal_concise = 4
instructor_feedback_pedal_clear = 2
instructor_feedback_pedal_jargon = 4
instructor_feedback_pedal_sentiment = 3

[bakery_nesting_list_dataclasses_code_good_job.Nosepass_31444935.py]
student_code = 
	from dataclasses import dataclass
	from bakery import assert_equal
	
	@dataclass
	class Job:
	    title: str
	    salary: int
	    available: bool
	    company: str
	    
	def filter_un(Jobs: list[Job])->list[Job]:
	    avalible_jobs = []
	    for job in Jobs:
	        if job.avalible:
	            avalible_jobs.append(job)
	    return avalible_jobs
	
	def best_job(Jobs: list[Job])->Job:
	    largest_salary = 0
	    filtered_jobs = filter_un(Jobs)
	    
	    if not filtered_jobs:
	        return Job("Unemployed", 0, True, "None")
	    
	    best_job = filtered_jobs[0]
	    for job in Jobs:
	        if job.salary > best_job.slary:
	            best_job = job
	    return best_job
	
	assert_equal(best_job([Job("Unemployed", 0, True, "None"),Job("Software Developer", 500000, False, "Google"),Job("TA",5,True,"Uni")]),Job("TA",5,True,"Uni"))
	assert_equal(best_job([Job("Unemployed", 0, True, "None"),Job("Software Developer", 500000, True, "Google"),Job("TA",5,True,"Uni")]),Job("Software Developer", 500000, True, "Google"))
	assert_equal(best_job([Job("Unemployed", 0, False, "None"),Job("Software Developer", 500000, False, "Google"),Job("TA",5,True,"Uni")]),Job("Unemployed", 0, True, "None"))
gpt_feedback = You have some misspellings in your code that will cause errors. The word 'available' is misspelled as 'avalible' in your filter_un function as well as in your Job class instantiation inside the 'if' condition. Also, in the second loop within the best_job function, 'salary' is misspelled as 'slary'. Please correct these spelling mistakes.
gpt_feedback_length = 53
gpt_score = 0.0
pedal_feedback = Do not remove or alter the starting code that we gave you. You may need to check your history or reset the problem.
pedal_feedback_length = 23
pedal_score = 0
instructor_feedback_gpt_accurate = 5
instructor_feedback_gpt_concise = 5
instructor_feedback_gpt_clear = 5
instructor_feedback_gpt_jargon = 2
instructor_feedback_gpt_sentiment = 3
instructor_feedback_pedal_accurate = 1
instructor_feedback_pedal_concise = 5
instructor_feedback_pedal_clear = 2
instructor_feedback_pedal_jargon = 1
instructor_feedback_pedal_sentiment = 2

[bakery_nesting_list_dataclasses_code_good_job.Nuzleaf_34424269.py]
student_code = 
	from dataclasses import dataclass
	from bakery import assert_equal
	
	@dataclass
	class Job:
	    title: str
	    salary: int
	    available: bool
	    company: str
	    
	def available_jobs(jobs:list[Job])->list[job]:
	    avail_jobs=[]
	    for job in jobs:
	        if job.available:
	            avail_jobs.append(job)
	    return avail_jobs
	
	def highest_salary(jobs:list[Job])->int:
	    maximum=jobs[0].salary
	    for job in jobs:
	        if maximum<job.salary:
	            maximum=job.salary
	    return maximum
	
	UNEMPLOYED = Job("Unemployed", 0, True, "None")
	
	def best_job(jobs:list[Job])->Job:
	    x=available_jobs(jobs)
	    if not x:
	        return UNEMPLOYED
	    y=highest_salary(x)
	    for job in jobs:
	        if job.salary==maximum:
	            return job   
	    
	
	list1:[Job("Dancer", 5000, True, "None"),Job("Driver", 200, True, "None")]
	list2:[Job("Painter",0, True, "None"),Job("Explorer", 200, False, "None")]
	list3:[Job("Hooper", 1000, False, "None"),Job("Scientist", 1200, False, "None")]
	
	assert_equal(best_job(list1), Job("Dancer", 5000, True, "None"))
	assert_equal(best_job(list2), Job("Painter",0, True, "None"))
	assert_equal(best_job(list3), UNEMPLOYED = Job("Unemployed", 0, True, "None"))
gpt_feedback = You've got the right idea! However, there are a couple of things that need fixing. First, the list you're using in the definition of highest_salary function should be pointing the maximum to y, not jobs[0].salary. Because y is the return value of the available_jobs function. Secondly, in your definition of best_job function, your 'if' condition should compare job.salary with y, not 'maximum'. Lastly, your assertion at the end where you compare best_job(list3) to UNEMPLOYED, remove the 'UNEMPLOYED = ' part.
gpt_feedback_length = 80
gpt_score = 0.0
pedal_feedback = The variable <code class='pedal-name'>job</code> was used on line 11, but it was not given a value on a previous line. You cannot use a variable until it has been given a value.
pedal_feedback_length = 32
pedal_score = 0
instructor_feedback_gpt_accurate = 5
instructor_feedback_gpt_concise = 2
instructor_feedback_gpt_clear = 5
instructor_feedback_gpt_jargon = 4
instructor_feedback_gpt_sentiment = 4
instructor_feedback_pedal_accurate = 3
instructor_feedback_pedal_concise = 4
instructor_feedback_pedal_clear = 2
instructor_feedback_pedal_jargon = 4
instructor_feedback_pedal_sentiment = 3

[bakery_structures_lists_code_book_list]
description = Create a list of 3 strings that represent the names of your favorite books and store them in a variable. Print this variable.

[bakery_structures_lists_code_book_list.Beedrill_23099060.py]
student_code = 
	books = ["the why axis", "I haven't read many books", "In a while"]
	
	print(books)
gpt_feedback = Your code seems fine. It correctly declares a list containing three book titles and prints it out. Remember that book titles usually start with a capital letter in English, but this doesn't affect the code correctness.
gpt_feedback_length = 36
gpt_score = 0.0
pedal_feedback = Great work!
pedal_feedback_length = 2
pedal_score = 1
instructor_feedback_gpt_accurate = 5
instructor_feedback_gpt_concise = 4
instructor_feedback_gpt_clear = 5
instructor_feedback_gpt_jargon = 1
instructor_feedback_gpt_sentiment = 5
instructor_feedback_pedal_accurate = 5
instructor_feedback_pedal_concise = 5
instructor_feedback_pedal_clear = 5
instructor_feedback_pedal_jargon = 1
instructor_feedback_pedal_sentiment = 5

[bakery_structures_lists_code_book_list.Buizel_24404096.py]
student_code = 
	book = ["dog" "dog" "doggy"]
gpt_feedback = It looks like you are attempting to create a list of strings. However, in Python, items in a list should be separated by commas. Right now, all your strings are combined into one. Try revising your code to have the format ['item1', 'item2', 'item3'].
gpt_feedback_length = 44
gpt_score = 0.0
pedal_feedback = The variable <code class='pedal-name'>book</code> was given a value on line 1, but was never used after that.
pedal_feedback_length = 17
pedal_score = 0
instructor_feedback_gpt_accurate = 5
instructor_feedback_gpt_concise = 5
instructor_feedback_gpt_clear = 5
instructor_feedback_gpt_jargon = 3
instructor_feedback_gpt_sentiment = 3
instructor_feedback_pedal_accurate = 3
instructor_feedback_pedal_concise = 4
instructor_feedback_pedal_clear = 2
instructor_feedback_pedal_jargon = 4
instructor_feedback_pedal_sentiment = 3

[bakery_structures_lists_code_book_list.Darumaka_24887472.py]
student_code = 
	books=["1", "2", "3"]
	print(books)
gpt_feedback = The code is working as expected; it successfully prints a list of strings. However, the strings in your list do not seem to represent book names. Try replacing the values '1', '2', and '3' with the titles of your favorite books to completely solve the problem.
gpt_feedback_length = 46
gpt_score = 0.0
pedal_feedback = Great work!
pedal_feedback_length = 2
pedal_score = 1
instructor_feedback_gpt_accurate = 5
instructor_feedback_gpt_concise = 5
instructor_feedback_gpt_clear = 5
instructor_feedback_gpt_jargon = 3
instructor_feedback_gpt_sentiment = 3
instructor_feedback_pedal_accurate = 4
instructor_feedback_pedal_concise = 5
instructor_feedback_pedal_clear = 4
instructor_feedback_pedal_jargon = 1
instructor_feedback_pedal_sentiment = 5

[bakery_structures_lists_code_book_list.Elgyem_22869578.py]
student_code = 
	# a list of 3 strings that represent the names of your favorite books 
	books=[Island,Firefly_Lane,Longevity]
	print(books)
gpt_feedback = Strings in Python must be enclosed in quotes. Ensure you wrap your book titles in either single (') or double (") quotes. Also remember that Python is case sensitive, hence variables and lists should generally be in lowercase.
gpt_feedback_length = 38
gpt_score = 0.0
pedal_feedback = The variable <code class='pedal-name'>Island</code> was used on line 2, but it was not given a value on a previous line. You cannot use a variable until it has been given a value.
pedal_feedback_length = 32
pedal_score = 0
instructor_feedback_gpt_accurate = 5
instructor_feedback_gpt_concise = 4
instructor_feedback_gpt_clear = 5
instructor_feedback_gpt_jargon = 2
instructor_feedback_gpt_sentiment = 3
instructor_feedback_pedal_accurate = 3
instructor_feedback_pedal_concise = 3
instructor_feedback_pedal_clear = 2
instructor_feedback_pedal_jargon = 4
instructor_feedback_pedal_sentiment = 3

[bakery_structures_lists_code_book_list.Girafarig_24550668.py]
student_code = 
	books = ["title 1", "title 2", "title 3"]
gpt_feedback = The code correctly created a list of book titles and stored it in the variable 'books'. Don't forget to add the code to print the list.
gpt_feedback_length = 26
gpt_score = 0.0
pedal_feedback = The variable <code class='pedal-name'>books</code> was given a value on line 2, but was never used after that.
pedal_feedback_length = 17
pedal_score = 0
instructor_feedback_gpt_accurate = 5
instructor_feedback_gpt_concise = 5
instructor_feedback_gpt_clear = 5
instructor_feedback_gpt_jargon = 2
instructor_feedback_gpt_sentiment = 3
instructor_feedback_pedal_accurate = 3
instructor_feedback_pedal_concise = 4
instructor_feedback_pedal_clear = 2
instructor_feedback_pedal_jargon = 4
instructor_feedback_pedal_sentiment = 3

[bakery_structures_lists_code_book_list.Lapras_23924730.py]
student_code = 
	Books = ['Harry Potter', 'Origami Yoda', 'Oregairu']
	print
gpt_feedback = It seems like you forgot to specify which variable to print. To print the list of books, you need to write: print(Books)
gpt_feedback_length = 22
gpt_score = 0.0
pedal_feedback = The variable <code class='pedal-name'>Books</code> was given a value on line 1, but was never used after that.
pedal_feedback_length = 17
pedal_score = 0
instructor_feedback_gpt_accurate = 5
instructor_feedback_gpt_concise = 5
instructor_feedback_gpt_clear = 5
instructor_feedback_gpt_jargon = 3
instructor_feedback_gpt_sentiment = 4
instructor_feedback_pedal_accurate = 3
instructor_feedback_pedal_concise = 4
instructor_feedback_pedal_clear = 2
instructor_feedback_pedal_jargon = 4
instructor_feedback_pedal_sentiment = 3

[bakery_structures_lists_code_book_list.Liepard_24011306.py]
student_code = 
	books = ["Harry Potter", "Lord of The Rings", "The Witcher"]
	print(book)
gpt_feedback = You have a spelling mistake in your print statement. You named your list as 'books' but trying to print 'book'. Update 'book' in the print statement to 'books'.
gpt_feedback_length = 28
gpt_score = 0.0
pedal_feedback = The variable <code class='pedal-name'>book</code> was used on line 2, but it was not given a value on a previous line. You cannot use a variable until it has been given a value.
pedal_feedback_length = 32
pedal_score = 0
instructor_feedback_gpt_accurate = 5
instructor_feedback_gpt_concise = 5
instructor_feedback_gpt_clear = 5
instructor_feedback_gpt_jargon = 3
instructor_feedback_gpt_sentiment = 3
instructor_feedback_pedal_accurate = 3
instructor_feedback_pedal_concise = 3
instructor_feedback_pedal_clear = 2
instructor_feedback_pedal_jargon = 4
instructor_feedback_pedal_sentiment = 3

[bakery_structures_lists_code_book_list.Nosepass_23407576.py]
student_code = 
	books = ['farquad','tichi','bro the book']
	print(books)
gpt_feedback = Your code is correct! You have successfully created a list of your favourite books and printed them out. Good job!
gpt_feedback_length = 20
gpt_score = 0.0
pedal_feedback = Great work!
pedal_feedback_length = 2
pedal_score = 1
instructor_feedback_gpt_accurate = 5
instructor_feedback_gpt_concise = 4
instructor_feedback_gpt_clear = 5
instructor_feedback_gpt_jargon = 1
instructor_feedback_gpt_sentiment = 5
instructor_feedback_pedal_accurate = 5
instructor_feedback_pedal_concise = 5
instructor_feedback_pedal_clear = 5
instructor_feedback_pedal_jargon = 1
instructor_feedback_pedal_sentiment = 5

[bakery_structures_lists_code_book_list.Nuzleaf_28121708.py]
student_code = 
	x=["Stella Luna", "Hunger Games", "A Game of Thrones"]
	print(x)
gpt_feedback = Good job! Your code is correct and you have neatly created an array of your favourite books and printed them out.
gpt_feedback_length = 21
gpt_score = 0.0
pedal_feedback = Great work!
pedal_feedback_length = 2
pedal_score = 1
instructor_feedback_gpt_accurate = 5
instructor_feedback_gpt_concise = 4
instructor_feedback_gpt_clear = 5
instructor_feedback_gpt_jargon = 1
instructor_feedback_gpt_sentiment = 5
instructor_feedback_pedal_accurate = 5
instructor_feedback_pedal_concise = 5
instructor_feedback_pedal_clear = 5
instructor_feedback_pedal_jargon = 1
instructor_feedback_pedal_sentiment = 5

[bakery_structures_lists_code_emptiness]
description = Print an empty list literal value. That's it, just directly print the empty list literal value.

[bakery_structures_lists_code_emptiness.Beedrill_23099121.py]
student_code = 
	print([])
gpt_feedback = Great job! You have successfully printed an empty list literal value.
gpt_feedback_length = 11
gpt_score = 0.0
pedal_feedback = Great work!
pedal_feedback_length = 2
pedal_score = 1
instructor_feedback_gpt_accurate = 5
instructor_feedback_gpt_concise = 5
instructor_feedback_gpt_clear = 5
instructor_feedback_gpt_jargon = 1
instructor_feedback_gpt_sentiment = 5
instructor_feedback_pedal_accurate = 5
instructor_feedback_pedal_concise = 5
instructor_feedback_pedal_clear = 5
instructor_feedback_pedal_jargon = 1
instructor_feedback_pedal_sentiment = 5

[bakery_structures_lists_code_emptiness.Buizel_24404292.py]
student_code = 
	empty = []
	print(empty)
gpt_feedback = Your code is correct! An empty list in Python is denoted as [], and you correctly assigned an empty list to the variable `empty` and printed it.
gpt_feedback_length = 27
gpt_score = 0.0
pedal_feedback = Great work!
pedal_feedback_length = 2
pedal_score = 1
instructor_feedback_gpt_accurate = 5
instructor_feedback_gpt_concise = 4
instructor_feedback_gpt_clear = 5
instructor_feedback_gpt_jargon = 1
instructor_feedback_gpt_sentiment = 5
instructor_feedback_pedal_accurate = 5
instructor_feedback_pedal_concise = 5
instructor_feedback_pedal_clear = 5
instructor_feedback_pedal_jargon = 1
instructor_feedback_pedal_sentiment = 5

[bakery_structures_lists_code_emptiness.Darumaka_24887664.py]
student_code = 
	empty=[]
	print(empty)
gpt_feedback = Good job! Your code is correct. You have created an empty list named 'empty' and printed it which is exactly what the problem asks for.
gpt_feedback_length = 25
gpt_score = 0.0
pedal_feedback = Great work!
pedal_feedback_length = 2
pedal_score = 1
instructor_feedback_gpt_accurate = 5
instructor_feedback_gpt_concise = 4
instructor_feedback_gpt_clear = 5
instructor_feedback_gpt_jargon = 1
instructor_feedback_gpt_sentiment = 5
instructor_feedback_pedal_accurate = 5
instructor_feedback_pedal_concise = 5
instructor_feedback_pedal_clear = 5
instructor_feedback_pedal_jargon = 1
instructor_feedback_pedal_sentiment = 5

[bakery_structures_lists_code_emptiness.Girafarig_24550838.py]
student_code = 
	print([])
gpt_feedback = Your code is correct! The syntax you used to print an empty list literal is the right approach in Python. Keep it up!
gpt_feedback_length = 23
gpt_score = 0.0
pedal_feedback = Great work!
pedal_feedback_length = 2
pedal_score = 1
instructor_feedback_gpt_accurate = 5
instructor_feedback_gpt_concise = 5
instructor_feedback_gpt_clear = 5
instructor_feedback_gpt_jargon = 1
instructor_feedback_gpt_sentiment = 5
instructor_feedback_pedal_accurate = 5
instructor_feedback_pedal_concise = 5
instructor_feedback_pedal_clear = 5
instructor_feedback_pedal_jargon = 1
instructor_feedback_pedal_sentiment = 5

[bakery_structures_lists_code_emptiness.Lapras_23924826.py]
student_code = 
	empty = []
	print(empty)
gpt_feedback = Great job! This code correctly creates an empty list, assigns it to the variable 'empty', and then prints it.
gpt_feedback_length = 19
gpt_score = 0.0
pedal_feedback = Great work!
pedal_feedback_length = 2
pedal_score = 1
instructor_feedback_gpt_accurate = 5
instructor_feedback_gpt_concise = 5
instructor_feedback_gpt_clear = 5
instructor_feedback_gpt_jargon = 1
instructor_feedback_gpt_sentiment = 5
instructor_feedback_pedal_accurate = 5
instructor_feedback_pedal_concise = 5
instructor_feedback_pedal_clear = 5
instructor_feedback_pedal_jargon = 1
instructor_feedback_pedal_sentiment = 5

[bakery_structures_lists_code_emptiness.Liepard_24011392.py]
student_code = 
	print([])
gpt_feedback = Great job! You've correctly used the print statement to print an empty list literal.
gpt_feedback_length = 14
gpt_score = 0.0
pedal_feedback = Great work!
pedal_feedback_length = 2
pedal_score = 1
instructor_feedback_gpt_accurate = 5
instructor_feedback_gpt_concise = 5
instructor_feedback_gpt_clear = 5
instructor_feedback_gpt_jargon = 1
instructor_feedback_gpt_sentiment = 5
instructor_feedback_pedal_accurate = 5
instructor_feedback_pedal_concise = 5
instructor_feedback_pedal_clear = 5
instructor_feedback_pedal_jargon = 1
instructor_feedback_pedal_sentiment = 5

[bakery_structures_lists_code_emptiness.Nosepass_23407797.py]
student_code = 
	List = []
	print(List)
gpt_feedback = Great job! Your code correctly defines and prints an empty list in Python.
gpt_feedback_length = 13
gpt_score = 0.0
pedal_feedback = Great work!
pedal_feedback_length = 2
pedal_score = 1
instructor_feedback_gpt_accurate = 5
instructor_feedback_gpt_concise = 5
instructor_feedback_gpt_clear = 5
instructor_feedback_gpt_jargon = 1
instructor_feedback_gpt_sentiment = 5
instructor_feedback_pedal_accurate = 5
instructor_feedback_pedal_concise = 5
instructor_feedback_pedal_clear = 5
instructor_feedback_pedal_jargon = 1
instructor_feedback_pedal_sentiment = 5

[bakery_structures_lists_code_emptiness.Nuzleaf_28121803.py]
student_code = 
	print([])
gpt_feedback = Good job! You've correctly printed an empty list literal value.
gpt_feedback_length = 10
gpt_score = 0.0
pedal_feedback = Great work!
pedal_feedback_length = 2
pedal_score = 1
instructor_feedback_gpt_accurate = 5
instructor_feedback_gpt_concise = 5
instructor_feedback_gpt_clear = 5
instructor_feedback_gpt_jargon = 1
instructor_feedback_gpt_sentiment = 5
instructor_feedback_pedal_accurate = 5
instructor_feedback_pedal_concise = 5
instructor_feedback_pedal_clear = 5
instructor_feedback_pedal_jargon = 1
instructor_feedback_pedal_sentiment = 5

